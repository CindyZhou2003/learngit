
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="个人向">
      
      
      
        <link rel="canonical" href="https://cindyzhou2003.github.io/mymkdocs/SE_courses/FDS/">
      
      
        <link rel="prev" href="../..">
      
      
        <link rel="next" href="../OOP/">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.10">
    
    
      
        <title>FDS - Cindy's Notebook</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.7e359304.min.css">
      
      
  
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
  
  <style>:root{--md-admonition-icon--note:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M1 7.775V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 0 1 0 2.474l-5.026 5.026a1.75 1.75 0 0 1-2.474 0l-6.25-6.25A1.752 1.752 0 0 1 1 7.775Zm1.5 0c0 .066.026.13.073.177l6.25 6.25a.25.25 0 0 0 .354 0l5.025-5.025a.25.25 0 0 0 0-.354l-6.25-6.25a.25.25 0 0 0-.177-.073H2.75a.25.25 0 0 0-.25.25ZM6 5a1 1 0 1 1 0 2 1 1 0 0 1 0-2Z"/></svg>');--md-admonition-icon--abstract:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M2.5 1.75v11.5c0 .138.112.25.25.25h3.17a.75.75 0 0 1 0 1.5H2.75A1.75 1.75 0 0 1 1 13.25V1.75C1 .784 1.784 0 2.75 0h8.5C12.216 0 13 .784 13 1.75v7.736a.75.75 0 0 1-1.5 0V1.75a.25.25 0 0 0-.25-.25h-8.5a.25.25 0 0 0-.25.25Zm13.274 9.537v-.001l-4.557 4.45a.75.75 0 0 1-1.055-.008l-1.943-1.95a.75.75 0 0 1 1.062-1.058l1.419 1.425 4.026-3.932a.75.75 0 1 1 1.048 1.074ZM4.75 4h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM4 7.75A.75.75 0 0 1 4.75 7h2a.75.75 0 0 1 0 1.5h-2A.75.75 0 0 1 4 7.75Z"/></svg>');--md-admonition-icon--info:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"/></svg>');--md-admonition-icon--tip:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M3.499.75a.75.75 0 0 1 1.5 0v.996C5.9 2.903 6.793 3.65 7.662 4.376l.24.202c-.036-.694.055-1.422.426-2.163C9.1.873 10.794-.045 12.622.26 14.408.558 16 1.94 16 4.25c0 1.278-.954 2.575-2.44 2.734l.146.508.065.22c.203.701.412 1.455.476 2.226.142 1.707-.4 3.03-1.487 3.898C11.714 14.671 10.27 15 8.75 15h-6a.75.75 0 0 1 0-1.5h1.376a4.484 4.484 0 0 1-.563-1.191 3.835 3.835 0 0 1-.05-2.063 4.647 4.647 0 0 1-2.025-.293.75.75 0 0 1 .525-1.406c1.357.507 2.376-.006 2.698-.318l.009-.01a.747.747 0 0 1 1.06 0 .748.748 0 0 1-.012 1.074c-.912.92-.992 1.835-.768 2.586.221.74.745 1.337 1.196 1.621H8.75c1.343 0 2.398-.296 3.074-.836.635-.507 1.036-1.31.928-2.602-.05-.603-.216-1.224-.422-1.93l-.064-.221c-.12-.407-.246-.84-.353-1.29a2.425 2.425 0 0 1-.507-.441 3.075 3.075 0 0 1-.633-1.248.75.75 0 0 1 1.455-.364c.046.185.144.436.31.627.146.168.353.305.712.305.738 0 1.25-.615 1.25-1.25 0-1.47-.95-2.315-2.123-2.51-1.172-.196-2.227.387-2.706 1.345-.46.92-.27 1.774.019 3.062l.042.19a.884.884 0 0 1 .01.05c.348.443.666.949.94 1.553a.75.75 0 1 1-1.365.62c-.553-1.217-1.32-1.94-2.3-2.768L6.7 5.527c-.814-.68-1.75-1.462-2.692-2.619a3.737 3.737 0 0 0-1.023.88c-.406.495-.663 1.036-.722 1.508.116.122.306.21.591.239.388.038.797-.06 1.032-.19a.75.75 0 0 1 .728 1.31c-.515.287-1.23.439-1.906.373-.682-.067-1.473-.38-1.879-1.193L.75 5.677V5.5c0-.984.48-1.94 1.077-2.664.46-.559 1.05-1.055 1.673-1.353V.75Z"/></svg>');--md-admonition-icon--success:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z"/></svg>');--md-admonition-icon--question:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.92 6.085h.001a.749.749 0 1 1-1.342-.67c.169-.339.436-.701.849-.977C6.845 4.16 7.369 4 8 4a2.756 2.756 0 0 1 1.637.525c.503.377.863.965.863 1.725 0 .448-.115.83-.329 1.15-.205.307-.47.513-.692.662-.109.072-.22.138-.313.195l-.006.004a6.24 6.24 0 0 0-.26.16.952.952 0 0 0-.276.245.75.75 0 0 1-1.248-.832c.184-.264.42-.489.692-.661.103-.067.207-.132.313-.195l.007-.004c.1-.061.182-.11.258-.161a.969.969 0 0 0 .277-.245C8.96 6.514 9 6.427 9 6.25a.612.612 0 0 0-.262-.525A1.27 1.27 0 0 0 8 5.5c-.369 0-.595.09-.74.187a1.01 1.01 0 0 0-.34.398ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"/></svg>');--md-admonition-icon--warning:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"/></svg>');--md-admonition-icon--failure:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M2.344 2.343h-.001a8 8 0 0 1 11.314 11.314A8.002 8.002 0 0 1 .234 10.089a8 8 0 0 1 2.11-7.746Zm1.06 10.253a6.5 6.5 0 1 0 9.108-9.275 6.5 6.5 0 0 0-9.108 9.275ZM6.03 4.97 8 6.94l1.97-1.97a.749.749 0 0 1 1.275.326.749.749 0 0 1-.215.734L9.06 8l1.97 1.97a.749.749 0 0 1-.326 1.275.749.749 0 0 1-.734-.215L8 9.06l-1.97 1.97a.749.749 0 0 1-1.275-.326.749.749 0 0 1 .215-.734L6.94 8 4.97 6.03a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018Z"/></svg>');--md-admonition-icon--danger:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M9.504.43a1.516 1.516 0 0 1 2.437 1.713L10.415 5.5h2.123c1.57 0 2.346 1.909 1.22 3.004l-7.34 7.142a1.249 1.249 0 0 1-.871.354h-.302a1.25 1.25 0 0 1-1.157-1.723L5.633 10.5H3.462c-1.57 0-2.346-1.909-1.22-3.004L9.503.429Zm1.047 1.074L3.286 8.571A.25.25 0 0 0 3.462 9H6.75a.75.75 0 0 1 .694 1.034l-1.713 4.188 6.982-6.793A.25.25 0 0 0 12.538 7H9.25a.75.75 0 0 1-.683-1.06l2.008-4.418.003-.006a.036.036 0 0 0-.004-.009l-.006-.006-.008-.001c-.003 0-.006.002-.009.004Z"/></svg>');--md-admonition-icon--bug:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M4.72.22a.75.75 0 0 1 1.06 0l1 .999a3.488 3.488 0 0 1 2.441 0l.999-1a.748.748 0 0 1 1.265.332.75.75 0 0 1-.205.729l-.775.776c.616.63.995 1.493.995 2.444v.327c0 .1-.009.197-.025.292.408.14.764.392 1.029.722l1.968-.787a.75.75 0 0 1 .556 1.392L13 7.258V9h2.25a.75.75 0 0 1 0 1.5H13v.5c0 .409-.049.806-.141 1.186l2.17.868a.75.75 0 0 1-.557 1.392l-2.184-.873A4.997 4.997 0 0 1 8 16a4.997 4.997 0 0 1-4.288-2.427l-2.183.873a.75.75 0 0 1-.558-1.392l2.17-.868A5.036 5.036 0 0 1 3 11v-.5H.75a.75.75 0 0 1 0-1.5H3V7.258L.971 6.446a.75.75 0 0 1 .558-1.392l1.967.787c.265-.33.62-.583 1.03-.722a1.677 1.677 0 0 1-.026-.292V4.5c0-.951.38-1.814.995-2.444L4.72 1.28a.75.75 0 0 1 0-1.06Zm.53 6.28a.75.75 0 0 0-.75.75V11a3.5 3.5 0 1 0 7 0V7.25a.75.75 0 0 0-.75-.75ZM6.173 5h3.654A.172.172 0 0 0 10 4.827V4.5a2 2 0 1 0-4 0v.327c0 .096.077.173.173.173Z"/></svg>');--md-admonition-icon--example:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M5 5.782V2.5h-.25a.75.75 0 0 1 0-1.5h6.5a.75.75 0 0 1 0 1.5H11v3.282l3.666 5.76C15.619 13.04 14.543 15 12.767 15H3.233c-1.776 0-2.852-1.96-1.899-3.458Zm-2.4 6.565a.75.75 0 0 0 .633 1.153h9.534a.75.75 0 0 0 .633-1.153L12.225 10.5h-8.45ZM9.5 2.5h-3V6c0 .143-.04.283-.117.403L4.73 9h6.54L9.617 6.403A.746.746 0 0 1 9.5 6Z"/></svg>');--md-admonition-icon--quote:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M1.75 2.5h10.5a.75.75 0 0 1 0 1.5H1.75a.75.75 0 0 1 0-1.5Zm4 5h8.5a.75.75 0 0 1 0 1.5h-8.5a.75.75 0 0 1 0-1.5Zm0 5h8.5a.75.75 0 0 1 0 1.5h-8.5a.75.75 0 0 1 0-1.5ZM2.5 7.75v6a.75.75 0 0 1-1.5 0v-6a.75.75 0 0 1 1.5 0Z"/></svg>');}</style>



    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../style.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Cindy&#39;s Notebook" class="md-header__button md-logo" aria-label="Cindy's Notebook" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Cindy's Notebook
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              FDS
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Cindy&#39;s Notebook" class="md-nav__button md-logo" aria-label="Cindy's Notebook" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Cindy's Notebook
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    主页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    SE
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            SE
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    FDS
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    FDS
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      引论
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sort" class="md-nav__link">
    <span class="md-ellipsis">
      排序 sort
    </span>
  </a>
  
    <nav class="md-nav" aria-label="排序 sort">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#quick-sort" class="md-nav__link">
    <span class="md-ellipsis">
      Quick Sort 快速排序
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#heap-sort" class="md-nav__link">
    <span class="md-ellipsis">
      Heap Sort 堆排序
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#insertion-sort" class="md-nav__link">
    <span class="md-ellipsis">
      Insertion Sort 插入排序
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shell-sort" class="md-nav__link">
    <span class="md-ellipsis">
      Shell Sort 希尔排序
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#selection-sort" class="md-nav__link">
    <span class="md-ellipsis">
      Selection Sort 选择排序
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#merge-sort" class="md-nav__link">
    <span class="md-ellipsis">
      Merge Sort 归并排序
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bucket-sort" class="md-nav__link">
    <span class="md-ellipsis">
      Bucket Sort 桶排序
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      间接/表排序
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#q" class="md-nav__link">
    <span class="md-ellipsis">
      Q
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hashing" class="md-nav__link">
    <span class="md-ellipsis">
      散列 hashing
    </span>
  </a>
  
    <nav class="md-nav" aria-label="散列 hashing">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      分离链接法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      开放定址法
    </span>
  </a>
  
    <nav class="md-nav" aria-label="开放定址法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#linear-probing" class="md-nav__link">
    <span class="md-ellipsis">
      线性探测法 Linear probing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quadratic-probing" class="md-nav__link">
    <span class="md-ellipsis">
      平方探测法 Quadratic probing
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#q_1" class="md-nav__link">
    <span class="md-ellipsis">
      Q
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#list" class="md-nav__link">
    <span class="md-ellipsis">
      表 List
    </span>
  </a>
  
    <nav class="md-nav" aria-label="表 List">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#q_2" class="md-nav__link">
    <span class="md-ellipsis">
      Q
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#stack" class="md-nav__link">
    <span class="md-ellipsis">
      栈 stack
    </span>
  </a>
  
    <nav class="md-nav" aria-label="栈 stack">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#q_3" class="md-nav__link">
    <span class="md-ellipsis">
      Q
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#queue" class="md-nav__link">
    <span class="md-ellipsis">
      队列 queue
    </span>
  </a>
  
    <nav class="md-nav" aria-label="队列 queue">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#q_4" class="md-nav__link">
    <span class="md-ellipsis">
      Q
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tree" class="md-nav__link">
    <span class="md-ellipsis">
      树 Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="树 Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Binary Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Binary Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#complete-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      完全二叉树 complete binary tree
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#insert" class="md-nav__link">
    <span class="md-ellipsis">
      insert 插入
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#binary-search-treebst" class="md-nav__link">
    <span class="md-ellipsis">
      二叉查找树 Binary Search Tree（BST）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delete" class="md-nav__link">
    <span class="md-ellipsis">
      Delete
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ternary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      ternary tree 三叉树
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#perfect-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Perfect binary tree 理想二叉树
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#q_5" class="md-nav__link">
    <span class="md-ellipsis">
      Q
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#heap" class="md-nav__link">
    <span class="md-ellipsis">
      堆 Heap 优先队列
    </span>
  </a>
  
    <nav class="md-nav" aria-label="堆 Heap 优先队列">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#insert_1" class="md-nav__link">
    <span class="md-ellipsis">
      Insert
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Insert">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#percolate-up" class="md-nav__link">
    <span class="md-ellipsis">
      上滤 percolate up
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#deletemin" class="md-nav__link">
    <span class="md-ellipsis">
      DeleteMin
    </span>
  </a>
  
    <nav class="md-nav" aria-label="DeleteMin">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#percolate-down" class="md-nav__link">
    <span class="md-ellipsis">
      下滤 percolate down
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#build" class="md-nav__link">
    <span class="md-ellipsis">
      Build
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#increasekey" class="md-nav__link">
    <span class="md-ellipsis">
      IncreaseKey
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#decreasekey" class="md-nav__link">
    <span class="md-ellipsis">
      DecreaseKey
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#relation" class="md-nav__link">
    <span class="md-ellipsis">
      关系 Relation
    </span>
  </a>
  
    <nav class="md-nav" aria-label="关系 Relation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equivalence-relation" class="md-nav__link">
    <span class="md-ellipsis">
      等价关系 equivalence relation
    </span>
  </a>
  
    <nav class="md-nav" aria-label="等价关系 equivalence relation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equivalence-class" class="md-nav__link">
    <span class="md-ellipsis">
      等价类 equivalence class
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unionfind" class="md-nav__link">
    <span class="md-ellipsis">
      Union/Find 算法（并查算法）
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Union/Find 算法（并查算法）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#find" class="md-nav__link">
    <span class="md-ellipsis">
      Find
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#union" class="md-nav__link">
    <span class="md-ellipsis">
      Union
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Union">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#union-by-size" class="md-nav__link">
    <span class="md-ellipsis">
      union-by-size 按大小求并
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#union-by-height" class="md-nav__link">
    <span class="md-ellipsis">
      union-by-height 按高度求并
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#path-compression" class="md-nav__link">
    <span class="md-ellipsis">
      路径压缩 path compression
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#q_6" class="md-nav__link">
    <span class="md-ellipsis">
      Q
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Q">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#graph" class="md-nav__link">
    <span class="md-ellipsis">
      图 Graph
    </span>
  </a>
  
    <nav class="md-nav" aria-label="图 Graph">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#introduction" class="md-nav__link">
    <span class="md-ellipsis">
      introduction
    </span>
  </a>
  
    <nav class="md-nav" aria-label="introduction">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#connected" class="md-nav__link">
    <span class="md-ellipsis">
      connected
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#articulation-pointcut-vertex" class="md-nav__link">
    <span class="md-ellipsis">
      割点 articulation point/cut vertex
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#topological" class="md-nav__link">
    <span class="md-ellipsis">
      拓扑排序 topological
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dijkstra-algorithm" class="md-nav__link">
    <span class="md-ellipsis">
      Dijkstra algorithm
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maximum-network-flow" class="md-nav__link">
    <span class="md-ellipsis">
      Maximum Network Flow  最大网络流
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Maximum Network Flow 最大网络流">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dinic" class="md-nav__link">
    <span class="md-ellipsis">
      Dinic
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mst" class="md-nav__link">
    <span class="md-ellipsis">
      MST 最小生成树
    </span>
  </a>
  
    <nav class="md-nav" aria-label="MST 最小生成树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#necessary-and-sufficient-condition-for-unique-mst" class="md-nav__link">
    <span class="md-ellipsis">
      Necessary-And-Sufficient-Condition-for-Unique-MST
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#prim" class="md-nav__link">
    <span class="md-ellipsis">
      Prim 算法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kruskal" class="md-nav__link">
    <span class="md-ellipsis">
      Kruskal 算法
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dfs" class="md-nav__link">
    <span class="md-ellipsis">
      DFS 深度优先搜索
    </span>
  </a>
  
    <nav class="md-nav" aria-label="DFS 深度优先搜索">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#find-articulation-point" class="md-nav__link">
    <span class="md-ellipsis">
      Find articulation point 找割点
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#strongly-connected-components" class="md-nav__link">
    <span class="md-ellipsis">
      Strongly Connected Components 强连通组件
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tarjan" class="md-nav__link">
    <span class="md-ellipsis">
      Tarjan 算法 找割点？还是强连通组件
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#q_7" class="md-nav__link">
    <span class="md-ellipsis">
      Q
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#questions" class="md-nav__link">
    <span class="md-ellipsis">
      Questions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Questions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#homework" class="md-nav__link">
    <span class="md-ellipsis">
      homework
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#midterm" class="md-nav__link">
    <span class="md-ellipsis">
      Midterm
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pta-code" class="md-nav__link">
    <span class="md-ellipsis">
      Pta code
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Pta code">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#true-or-flase" class="md-nav__link">
    <span class="md-ellipsis">
      True or Flase
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#function" class="md-nav__link">
    <span class="md-ellipsis">
      function
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../OOP/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    OOP
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    other
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            other
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../other/IELTs/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    IELTs
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../other/test/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Test
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      引论
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sort" class="md-nav__link">
    <span class="md-ellipsis">
      排序 sort
    </span>
  </a>
  
    <nav class="md-nav" aria-label="排序 sort">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#quick-sort" class="md-nav__link">
    <span class="md-ellipsis">
      Quick Sort 快速排序
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#heap-sort" class="md-nav__link">
    <span class="md-ellipsis">
      Heap Sort 堆排序
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#insertion-sort" class="md-nav__link">
    <span class="md-ellipsis">
      Insertion Sort 插入排序
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shell-sort" class="md-nav__link">
    <span class="md-ellipsis">
      Shell Sort 希尔排序
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#selection-sort" class="md-nav__link">
    <span class="md-ellipsis">
      Selection Sort 选择排序
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#merge-sort" class="md-nav__link">
    <span class="md-ellipsis">
      Merge Sort 归并排序
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bucket-sort" class="md-nav__link">
    <span class="md-ellipsis">
      Bucket Sort 桶排序
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      间接/表排序
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#q" class="md-nav__link">
    <span class="md-ellipsis">
      Q
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#hashing" class="md-nav__link">
    <span class="md-ellipsis">
      散列 hashing
    </span>
  </a>
  
    <nav class="md-nav" aria-label="散列 hashing">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      分离链接法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      开放定址法
    </span>
  </a>
  
    <nav class="md-nav" aria-label="开放定址法">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#linear-probing" class="md-nav__link">
    <span class="md-ellipsis">
      线性探测法 Linear probing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quadratic-probing" class="md-nav__link">
    <span class="md-ellipsis">
      平方探测法 Quadratic probing
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#q_1" class="md-nav__link">
    <span class="md-ellipsis">
      Q
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#list" class="md-nav__link">
    <span class="md-ellipsis">
      表 List
    </span>
  </a>
  
    <nav class="md-nav" aria-label="表 List">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#q_2" class="md-nav__link">
    <span class="md-ellipsis">
      Q
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#stack" class="md-nav__link">
    <span class="md-ellipsis">
      栈 stack
    </span>
  </a>
  
    <nav class="md-nav" aria-label="栈 stack">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#q_3" class="md-nav__link">
    <span class="md-ellipsis">
      Q
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#queue" class="md-nav__link">
    <span class="md-ellipsis">
      队列 queue
    </span>
  </a>
  
    <nav class="md-nav" aria-label="队列 queue">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#q_4" class="md-nav__link">
    <span class="md-ellipsis">
      Q
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tree" class="md-nav__link">
    <span class="md-ellipsis">
      树 Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="树 Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Binary Tree
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Binary Tree">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#complete-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      完全二叉树 complete binary tree
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#insert" class="md-nav__link">
    <span class="md-ellipsis">
      insert 插入
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#binary-search-treebst" class="md-nav__link">
    <span class="md-ellipsis">
      二叉查找树 Binary Search Tree（BST）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delete" class="md-nav__link">
    <span class="md-ellipsis">
      Delete
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ternary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      ternary tree 三叉树
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#perfect-binary-tree" class="md-nav__link">
    <span class="md-ellipsis">
      Perfect binary tree 理想二叉树
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#q_5" class="md-nav__link">
    <span class="md-ellipsis">
      Q
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#heap" class="md-nav__link">
    <span class="md-ellipsis">
      堆 Heap 优先队列
    </span>
  </a>
  
    <nav class="md-nav" aria-label="堆 Heap 优先队列">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#insert_1" class="md-nav__link">
    <span class="md-ellipsis">
      Insert
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Insert">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#percolate-up" class="md-nav__link">
    <span class="md-ellipsis">
      上滤 percolate up
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#deletemin" class="md-nav__link">
    <span class="md-ellipsis">
      DeleteMin
    </span>
  </a>
  
    <nav class="md-nav" aria-label="DeleteMin">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#percolate-down" class="md-nav__link">
    <span class="md-ellipsis">
      下滤 percolate down
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#build" class="md-nav__link">
    <span class="md-ellipsis">
      Build
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#increasekey" class="md-nav__link">
    <span class="md-ellipsis">
      IncreaseKey
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#decreasekey" class="md-nav__link">
    <span class="md-ellipsis">
      DecreaseKey
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#relation" class="md-nav__link">
    <span class="md-ellipsis">
      关系 Relation
    </span>
  </a>
  
    <nav class="md-nav" aria-label="关系 Relation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equivalence-relation" class="md-nav__link">
    <span class="md-ellipsis">
      等价关系 equivalence relation
    </span>
  </a>
  
    <nav class="md-nav" aria-label="等价关系 equivalence relation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equivalence-class" class="md-nav__link">
    <span class="md-ellipsis">
      等价类 equivalence class
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unionfind" class="md-nav__link">
    <span class="md-ellipsis">
      Union/Find 算法（并查算法）
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Union/Find 算法（并查算法）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#find" class="md-nav__link">
    <span class="md-ellipsis">
      Find
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#union" class="md-nav__link">
    <span class="md-ellipsis">
      Union
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Union">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#union-by-size" class="md-nav__link">
    <span class="md-ellipsis">
      union-by-size 按大小求并
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#union-by-height" class="md-nav__link">
    <span class="md-ellipsis">
      union-by-height 按高度求并
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#path-compression" class="md-nav__link">
    <span class="md-ellipsis">
      路径压缩 path compression
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#q_6" class="md-nav__link">
    <span class="md-ellipsis">
      Q
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Q">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#graph" class="md-nav__link">
    <span class="md-ellipsis">
      图 Graph
    </span>
  </a>
  
    <nav class="md-nav" aria-label="图 Graph">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#introduction" class="md-nav__link">
    <span class="md-ellipsis">
      introduction
    </span>
  </a>
  
    <nav class="md-nav" aria-label="introduction">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#connected" class="md-nav__link">
    <span class="md-ellipsis">
      connected
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#articulation-pointcut-vertex" class="md-nav__link">
    <span class="md-ellipsis">
      割点 articulation point/cut vertex
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#topological" class="md-nav__link">
    <span class="md-ellipsis">
      拓扑排序 topological
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dijkstra-algorithm" class="md-nav__link">
    <span class="md-ellipsis">
      Dijkstra algorithm
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maximum-network-flow" class="md-nav__link">
    <span class="md-ellipsis">
      Maximum Network Flow  最大网络流
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Maximum Network Flow 最大网络流">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dinic" class="md-nav__link">
    <span class="md-ellipsis">
      Dinic
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mst" class="md-nav__link">
    <span class="md-ellipsis">
      MST 最小生成树
    </span>
  </a>
  
    <nav class="md-nav" aria-label="MST 最小生成树">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#necessary-and-sufficient-condition-for-unique-mst" class="md-nav__link">
    <span class="md-ellipsis">
      Necessary-And-Sufficient-Condition-for-Unique-MST
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#prim" class="md-nav__link">
    <span class="md-ellipsis">
      Prim 算法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kruskal" class="md-nav__link">
    <span class="md-ellipsis">
      Kruskal 算法
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dfs" class="md-nav__link">
    <span class="md-ellipsis">
      DFS 深度优先搜索
    </span>
  </a>
  
    <nav class="md-nav" aria-label="DFS 深度优先搜索">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#find-articulation-point" class="md-nav__link">
    <span class="md-ellipsis">
      Find articulation point 找割点
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#strongly-connected-components" class="md-nav__link">
    <span class="md-ellipsis">
      Strongly Connected Components 强连通组件
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tarjan" class="md-nav__link">
    <span class="md-ellipsis">
      Tarjan 算法 找割点？还是强连通组件
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#q_7" class="md-nav__link">
    <span class="md-ellipsis">
      Q
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#questions" class="md-nav__link">
    <span class="md-ellipsis">
      Questions
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Questions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#homework" class="md-nav__link">
    <span class="md-ellipsis">
      homework
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#midterm" class="md-nav__link">
    <span class="md-ellipsis">
      Midterm
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pta-code" class="md-nav__link">
    <span class="md-ellipsis">
      Pta code
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Pta code">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#true-or-flase" class="md-nav__link">
    <span class="md-ellipsis">
      True or Flase
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#function" class="md-nav__link">
    <span class="md-ellipsis">
      function
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="https://www.cnblogs.com/nonlinearthink/p/11735810.html">数据结构与算法（周测1-算法分析） - nonlinearthink - 博客园</a></p>
<h2 id="_1">引论</h2>
<p>ADT abstract data type 抽象数据类型<br />
$O(N)≤$ <br />
$Ω(N)≥$ <br />
$Θ(N)=$ <br />
$o(N)＜$<br /></p>
<h2 id="sort">排序 sort</h2>
<p><strong>stable 稳定</strong>: A sorting algorithm is said to be stable if two items with equal keys _in the same order _in the sorted output as they appear in the input array. That is, the order of elements with identical keys is preserved.</p>
<h3 id="quick-sort">Quick Sort 快速排序</h3>
<p><a href="https://www.geeksforgeeks.org/quick-sort/"><em><strong>Quick Sort</strong></em></a><em><strong> </strong>is a sorting algorithm that works using the divide-and-conquer approach. It chooses a pivot places it in its correct position in the sorted array and partitions the smaller elements to its left and the greater ones to its right. This process is continued for the left and right parts and the array is sorted.</em><br />两边分组排序<br />时间复杂度：$O(N logN)$平均<br />每一轮排序 run 都有一个数 pivot 被放到最终正确的位置上<br />The position of the pivot element is finalized after each partitioning.</p>
<h3 id="heap-sort">Heap Sort 堆排序</h3>
<p><a href="https://www.geeksforgeeks.org/heap-sort/">Heap Sort - Data Structures and Algorithms Tutorials - GeeksforGeeks</a><br /><strong>Heap sort</strong><em> is a comparison-based sorting technique based on </em><a href="http://www.geeksforgeeks.org/binary-heap/">Binary Heap</a><em> data structure. It is similar to the </em><a href="http://www.geeksforgeeks.org/selection-sort/">selection sort</a><em> where we first find the minimum element and place the minimum element at the beginning. Repeat the same process for the remaining elements.</em><br /><em>首先使用 heapify (percolate down) 将数组转换为堆数据结构，然后逐个删除 Max-heap 的根节点，将其替换为堆中的最后一个节点，然后堆化堆的根。重复此过程，直到堆的大小大于 1。</em></p>
<ul>
<li><em>从给定的输入数组构建堆。</em></li>
<li><em>重复以下步骤，直到堆只包含一个元素：</em></li>
<li><em>将堆的根元素（即最大的元素）与堆的最后一个元素交换。</em></li>
<li><em>删除堆的最后一个元素（现在位于正确位置）。</em></li>
<li><em>堆砌堆的其余元素。</em></li>
<li><em>排序后的数组是通过反转输入数组中元素的顺序来获得的。</em></li>
</ul>
<p>性质：unstable<br />时间复杂度：$O(N)$??
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="c1">// Function to swap the position of two elements</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// To heapify a subtree rooted with node i</span>
<span class="c1">// which is an index in arr[].</span>
<span class="c1">// n is size of heap</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">heapify</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Find largest among root,</span>
<span class="w">    </span><span class="c1">// left child and right child</span>

<span class="w">    </span><span class="c1">// Initialize largest as root</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// left = 2*i + 1</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// right = 2*i + 2</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// If left child is larger than root</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">left</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">])</span>

<span class="w">        </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">left</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// If right child is larger than largest</span>
<span class="w">    </span><span class="c1">// so far</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">right</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">])</span>

<span class="w">        </span><span class="n">largest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Swap and continue heapifying</span>
<span class="w">    </span><span class="c1">// if root is not largest</span>
<span class="w">    </span><span class="c1">// If largest is not root</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">largest</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">largest</span><span class="p">]);</span>

<span class="w">        </span><span class="c1">// Recursively heapify the affected</span>
<span class="w">        </span><span class="c1">// sub-tree</span>
<span class="w">        </span><span class="n">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">largest</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Main function to do heap sort</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">heapSort</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span>
<span class="p">{</span>

<span class="w">    </span><span class="c1">// Build max heap</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">)</span>

<span class="w">        </span><span class="n">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Heap sort</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

<span class="w">        </span><span class="c1">// Heapify root element</span>
<span class="w">        </span><span class="c1">// to get highest element at</span>
<span class="w">        </span><span class="c1">// root again</span>
<span class="w">        </span><span class="n">heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// A utility function to print array of size n</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">printArray</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Driver&#39;s code</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="w">    </span><span class="c1">// Function call</span>
<span class="w">    </span><span class="n">heapSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Sorted array is</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printArray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="insertion-sort">Insertion Sort 插入排序</h3>
<p><a href="https://www.geeksforgeeks.org/insertion-sort/">Insertion Sort - Data Structure and Algorithm Tutorials - GeeksforGeeks</a><br /><strong><em>Insertion sort</em></strong><em> is a simple sorting algorithm that works similarly to the way you sort playing cards in your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part are picked and placed at the correct position in the sorted part.</em><br /><em>若要按升序对大小为 N 的数组进行排序，请遍历该数组并将当前元素（键）与其前一个元素进行比较，如果关键元素小于其前一个元素，请将其与之前的元素进行比较。将较大的元素向上移动一个位置，以便为交换的元素腾出空间。</em><br />时间复杂度：
<div class="highlight"><pre><span></span><code><span class="c1">// C++ program for insertion sort</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;bits/stdc++.h&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>
<span class="c1">// Function to sort an array using insertion sort</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">insertionSort</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="w">        </span><span class="c1">// Move elements of arr[0..i-1],</span>
<span class="w">        </span><span class="c1">// that are greater than key, </span>
<span class="w">        </span><span class="c1">// to one position ahead of their</span>
<span class="w">        </span><span class="c1">// current position</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">key</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">--</span><span class="p">){</span>
<span class="w">            </span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="mi">-1</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">// A utility function to print an array of size n</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">printArray</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Driver code</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="w">    </span><span class="n">insertionSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span>
<span class="w">    </span><span class="n">printArray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// This is code is contributed by rathbhupendra</span>
</code></pre></div></p>
<h3 id="shell-sort">Shell Sort 希尔排序</h3>
<p><a href="http://en.wikipedia.org/wiki/Shellsort"><em><strong>Shell sort</strong></em></a><em><strong> </strong><strong>i</strong>s mainly a variation of </em><a href="https://www.geeksforgeeks.org/insertion-sort/"><em>Insertion Sort</em></a><em>. In insertion sort, we move elements only one position ahead. When an element has to be moved far ahead, many movements are involved. The idea of ShellSort is to allow the exchange of far items. In Shell sort, we make the array h-sorted for a large value of h. We keep reducing the value of h until it becomes 1.  An array is said to be h-sorted if all sublists of every h’th element are sorted.</em><br /><em>分组 h-插入排序</em><br />性质： unstable<br />时间复杂度：<br /><strong>Algorithm:</strong><br />Step 1 − Start<br />Step 2 − Initialize the value of gap size. Example: h.<br />Step 3 − Divide the list into smaller sub-part. Each must have equal intervals to h.<br />Step 4 − Sort these sub-lists using insertion sort.<br />Step 5 – Repeat this step 2 until the list is sorted.<br />Step 6 – Print a sorted list.<br />Step 7 – Stop.</p>
<p><div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">Shellsort</span><span class="p">(</span><span class="w"> </span><span class="n">ElementType</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="w"> </span><span class="p">],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="p">)</span><span class="w"> </span>
<span class="p">{</span><span class="w"> </span>
<span class="w">      </span><span class="kt">int</span><span class="w">  </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">Increment</span><span class="p">;</span><span class="w"> </span>
<span class="w">      </span><span class="n">ElementType</span><span class="w">  </span><span class="n">Tmp</span><span class="p">;</span><span class="w"> </span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">Increment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">Increment</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">Increment</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">)</span><span class="w">  </span>
<span class="w">    </span><span class="cm">/*h sequence */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Increment</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* insertion sort */</span>
<span class="w">          </span><span class="n">Tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="p">];</span><span class="w"> </span>
<span class="w">          </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">Increment</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Increment</span><span class="w"> </span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="n">Tmp</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">Increment</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="p">)</span><span class="w"> </span>
<span class="w">              </span><span class="n">A</span><span class="p">[</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">Increment</span><span class="w"> </span><span class="p">];</span><span class="w"> </span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span>
<span class="w">              </span><span class="k">break</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="n">A</span><span class="p">[</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Tmp</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="cm">/* end for-I and for-Increment loops */</span>
<span class="p">}</span>
</code></pre></div>
Hibbard 增量序列<br />$H_k=2^k-1$, 且其最坏情形下运行时间为 $O(N^{3/2})$</p>
<h3 id="selection-sort">Selection Sort 选择排序</h3>
<h3 id="merge-sort">Merge Sort 归并排序</h3>
<p>性质： stable<br />时间复杂度：$O(N logN)$
<div class="highlight"><pre><span></span><code><span class="c1">// C program for Merge Sort</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>
<span class="c1">// Merges two subarrays of arr[].</span>
<span class="c1">// First subarray is arr[l..m]</span>
<span class="c1">// Second subarray is arr[m+1..r]</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">merge</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Create temp arrays</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">L</span><span class="p">[</span><span class="n">n1</span><span class="p">],</span><span class="w"> </span><span class="n">R</span><span class="p">[</span><span class="n">n2</span><span class="p">];</span>

<span class="w">    </span><span class="c1">// Copy data to temp arrays L[] and R[]</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">l</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n2</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">m</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">];</span>

<span class="w">    </span><span class="c1">// Merge the temp arrays back into arr[l..r</span>
<span class="w">    </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">            </span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<span class="w">            </span><span class="n">j</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">k</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Copy the remaining elements of L[],</span>
<span class="w">    </span><span class="c1">// if there are any</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="n">k</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Copy the remaining elements of R[],</span>
<span class="w">    </span><span class="c1">// if there are any</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
<span class="w">        </span><span class="n">j</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="n">k</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// l is for left index and r is right index of the</span>
<span class="c1">// sub-array of arr to be sorted</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">mergeSort</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">l</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">l</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Sort first and second halves</span>
<span class="w">        </span><span class="n">mergeSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">);</span>
<span class="w">        </span><span class="n">mergeSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span>

<span class="w">        </span><span class="n">merge</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">l</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Function to print an array</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">printArray</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Driver code</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">arr</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">arr_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Given array is </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printArray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">arr_size</span><span class="p">);</span>

<span class="w">    </span><span class="n">mergeSort</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">arr_size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Sorted array is </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">printArray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">arr_size</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="bucket-sort">Bucket Sort 桶排序</h3>
<h3 id="_2">间接/表排序</h3>
<p>排序的元素是结构大，移动指针数组进行排序<br />N 个数字的排列一定是由若干个独立的环组成的</p>
<ul>
<li>每访问一个环，当<code>table[i]==i</code>时环结束</li>
</ul>
<p><strong>时间复杂度</strong>：（最坏）向下取整 N/2 个环，每个环包括两个元素； 总$O(M*n)$，M 是每个元素 A 复制的时间</p>
<h3 id="q">Q</h3>
<ol>
<li>If there are less than 20 inversions in an integer array, then Insertion Sort will be the best method among Quick Sort, Heap Sort and Insertion Sort. <strong>T</strong></li>
<li>For the quicksort implementation with the left pointer stops at an element with the same key as the pivot during the partitioning, but the right pointer does not stop in a similar case, what is the running time when all keys are equal?</li>
<li>$O(logN)$</li>
<li>$O(N)$</li>
<li>$O(NlogN)$</li>
<li>$O(N^2)$</li>
</ol>
<p>The running time is $O(n^2)$ in the worst case [<a href="http://staff.ustc.edu.cn/~csli/graduate/algorithms/book6/chap08.htm">6</a>]. This is because in such a situation, the partitioning doesn't effectively divide the array into smaller subproblems, leading to a degenerate case where the algorithm essentially performs a linear scan. Quicksort's typical efficiency relies on dividing the problem into subproblems, and when this doesn't occur due to equal keys, the algorithm's performance degrades.（answer from AI）</p>
<ol>
<li>To sort { 49, 38, 65, 97, 76, 13, 27, 50 } in <strong>increasing order</strong>, which of the following is the result after the 1st run of <em>Shell sort</em> with the initial increment 4? </li>
<li>13,27,38,49,50,65,76,97</li>
<li>49,13,27,50,76,38,65,97</li>
<li>49,76,65,13,27,50,97,38</li>
<li>97,76,65,50,49,38,27,13</li>
</ol>
<p>First Pass (Increment 4):</p>
<ul>
<li>Compare elements at positions 1 and 5 (49 and 76), no swap needed.</li>
<li>Compare elements at positions 2 and 6 (38 and 13), swap.</li>
<li>Compare elements at positions 3 and 7 (65 and 27), swap.</li>
<li>Compare elements at positions 4 and 8 (97 and 50), swap.</li>
<li>if not present due to length, no swap needed.</li>
<li>
<p>Among the following sorting methods, which ones will be <em>slowed down</em> if we store the elements in a <strong>linked structure</strong> instead of a sequential structure? </p>
</li>
<li>
<p>Insertion sort; 2. Select ion Sort; 3. Bubble sort; 4. Shell sort; 5. Heap sort</p>
</li>
<li>
<p>1 and 2 only</p>
</li>
<li>2 and 3 only</li>
<li>3 and 4 only</li>
<li>4 and 5 only</li>
</ul>
<p>Heap sort是在数组中, heap本身在数组中, shell sort也是在数组中， 链表查询较慢</p>
<ol>
<li>To sort <em>N</em> elements by heap sort, the extra space complexity is: $O(1)$</li>
<li>During the sorting, processing every element which is not yet at its final position is called a "run". To sort a list of integers using quick sort, it may reduce the total number of recursions by processing the small partion first in each run. **F **</li>
</ol>
<p>希望平均分，处理两个都一样的</p>
<ol>
<li><br /></li>
</ol>
<h2 id="hashing">散列 hashing</h2>
<p>冲突 collision：Two elements with different keys share the <strong>same hash value</strong><br />装填因子 load factor: $λ=n/tablesize$<br />散列平均查找期望是$O(1)$，几乎与关键字空间 n 无关</p>
<ul>
<li>以较小的装填因子为前提，以空间换时间</li>
<li>不便于顺序查找关键字、范围查找、最大最小值查找等</li>
</ul>
<h3 id="_3">分离链接法</h3>
<p>把所有有冲突的 key 用链表串联在一起<br />装填因子可能超过 1，成功查找期望略大于不成功<br />链表储存效率和查找效率比较低<br />关键字删除不需要“懒惰删除”法<br />太小的装填因子可能浪费空间，太大将付出时间代价</p>
<h3 id="_4">开放定址法</h3>
<p>如果发生第 i 次冲突，探测的下一个地址+di<br />装填因子越大，（不）成功查找期望次数越大（指数级增长，不成功&gt;成功）；装填因子较小时，各种期望探测次数都不大且比较接近。<br />散列表是个数组，储存效率高，随机查找，有聚集现象</p>
<h4 id="linear-probing">线性探测法 Linear probing</h4>
<p>$di=i$<br /><strong>平均查找长度（次数）</strong>一般失败&gt;成功<br />成功查找长度 ASLs：散列中每个元素要找 xi 次（xi=冲突次数+1），相加取平均（➗实际哈希表元素个数）<br />失败查找长度 ASLu：找不在散列中的元素，对于每个哈希值 h(x)， 照样 mod + 后移找，若是遇到空格则证明不在散列中，此时的查找次数 xi 相加取平均</p>
<h4 id="quadratic-probing">平方探测法 Quadratic probing</h4>
<p>增量序列：1，-1，$2^2$，$-2^2$，$3^2$，$-3^2$, …… ,$q^2$,$-q^2$且 $q≤⌊tablesize/2⌋$<br />可能出现表有位置但找不到的情况（$i^2$也一样 )<br />使用平方探测法：<br />当表的大小是素数且表有一半是空的的时候，总能插入一个新的元素<br />如果表的大小是形如 4k+3 的素数，使用 $F(i)=+-i^2$，那么整个表都能被探测到</p>
<h3 id="q_1">Q</h3>
<ol>
<li>Which of the following statements about HASH is true? </li>
<li>the expected number of probes for insertions is greater than that for successful searches in linear probing method</li>
<li>insertions are generally quicker than deletions in separate chaining method</li>
<li>if the table size is prime and the table is at least half empty, a new element can always be inserted with quadratic probing</li>
<li>all of the above</li>
<li>The average search time of searching a hash table with N elements is:</li>
<li>$O(1)$</li>
<li>$O(logN)$</li>
<li>$O(N)$</li>
<li>cannot be determined</li>
</ol>
<h2 id="list">表 List</h2>
<h3 id="q_2">Q</h3>
<p>For a <strong>sequentially stored linear list</strong> of length <em>N</em>, the time complexities for <strong>query</strong> and <strong>insertion</strong> are <em><strong>O</strong></em><strong>(1</strong>) and <em><strong>O</strong></em><strong>(</strong><em><strong>N</strong></em>), respectively. <strong>T</strong></p>
<h2 id="stack">栈 stack</h2>
<p><strong>栈</strong>（Stack）：是只允许在一端进行插入或删除的<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E6%80%A7%E8%A1%A8&amp;spm=1001.2101.3001.7020">线性表</a>。首先栈是一种<a href="https://blog.csdn.net/Real_Fool_/article/details/113463997">线性表</a>，但限定这种线性表只能在某一端进行插入和删除操作。<br /><strong>Last-in-First-out</strong>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">Push</span><span class="p">(</span><span class="n">Elementstype</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">Stack</span><span class="w"> </span><span class="n">S</span><span class="p">){</span>
<span class="w">    </span><span class="n">PtrtoNode</span><span class="w"> </span><span class="n">Tmp</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//略去判断是不是NULL</span>
<span class="w">    </span><span class="n">Tmp</span><span class="o">-&gt;</span><span class="n">Element</span><span class="o">=</span><span class="n">X</span><span class="p">;</span>
<span class="w">    </span><span class="n">Tmp</span><span class="o">-&gt;</span><span class="n">Next</span><span class="o">=</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span><span class="c1">//换表头</span>
<span class="w">    </span><span class="n">S</span><span class="o">-&gt;</span><span class="n">Next</span><span class="o">=</span><span class="n">Tmp</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Pop</span><span class="p">(</span><span class="n">Stack</span><span class="w"> </span><span class="n">S</span><span class="p">){</span>
<span class="w">    </span><span class="n">PtrtoNode</span><span class="w"> </span><span class="n">first</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//略去判断是不是空</span>
<span class="w">    </span><span class="n">first</span><span class="o">=</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
<span class="w">    </span><span class="n">S</span><span class="o">-&gt;</span><span class="n">Next</span><span class="o">=</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">Next</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span><span class="c1">//换表头</span>
<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">first</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">Push</span><span class="p">(</span><span class="n">Stack</span><span class="w"> </span><span class="n">S</span><span class="p">){</span>
<span class="w">    </span><span class="c1">//略去判断是不是满了</span>
<span class="w">    </span><span class="n">S</span><span class="o">-&gt;</span><span class="n">Array</span><span class="p">[</span><span class="o">++</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">TopOfStack</span><span class="p">]</span><span class="o">=</span><span class="n">X</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Pop</span><span class="p">(</span><span class="n">Stack</span><span class="w"> </span><span class="n">S</span><span class="p">){</span>
<span class="w">    </span><span class="c1">//略去判断是不是空</span>
<span class="w">    </span><span class="n">S</span><span class="o">-&gt;</span><span class="n">TopOfStack</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="q_3">Q</h3>
<ul>
<li>Stacks and queues are lists with insertion/deletion constraints.</li>
</ul>
<h2 id="queue">队列 queue</h2>
<p>First-in-first-out<br />circular array<br />检测队列是不是空是很重要的</p>
<h3 id="q_4">Q</h3>
<p>Suppose that an array of size m is used to store a <strong>circular queue</strong>. If the front position is front and the current size is size, then the rear element must be at <em>(front+size-1)%m.</em></p>
<h2 id="tree">树 Tree</h2>
<p>深度 根 到 节点 ni （根的深度为 0，树的深度是它最深树叶的深度）<br />高度 节点 ni 到叶子 （树的高度是根的高度）<br />路径 节点的一个顺序，一棵树中从根到每个节点恰好存在一条路径<br /><img alt="" src="https://cdn.nlark.com/yuque/0/2023/png/34417153/1700400762937-40c9825f-e1ed-4a24-b3a9-2a600819f6b9.png#averageHue=%23302c28&amp;clientId=u28924e74-1e87-4&amp;from=paste&amp;id=u98aa1043&amp;originHeight=414&amp;originWidth=377&amp;originalType=url&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6b17a932-7c29-431b-bcd0-529186d6d36&amp;title=" /></p>
<h3 id="binary-tree">Binary Tree</h3>
<p>度数为 0 的节点 = 度数为 2 的节点+1</p>
<h4 id="complete-binary-tree">完全二叉树 complete binary tree</h4>
<p>The parent of a node at index _i _ is located at index $⌊i/2⌋$</p>
<h4 id="insert">insert 插入</h4>
<p>如果队列里没有 X，<code>Insert(Elemnettype X, SearchTree T)</code>将 X 插入到遍历路径的最后一点上</p>
<h4 id="binary-search-treebst">二叉查找树 Binary Search Tree（BST）</h4>
<p>左边都比根小，右边都比根大<br />树的平均深度 $O(Nlog N)$</p>
<h4 id="delete">Delete</h4>
<p>左子树最大或者右子树最小的数来代替被删掉的节点（不是叶子</p>
<h4 id="ternary-tree">ternary tree 三叉树</h4>
<p>The number of leaf nodes in a ternary tree (三叉树) is only related to the number of degree 2 nodes and that of degree 3 nodes, namely, it has nothing to do with the number of degree 1 nodes.</p>
<h4 id="perfect-binary-tree">Perfect binary tree 理想二叉树</h4>
<p>满二叉树，是一种特殊类型的二叉树。在理想二叉树中，除了叶子节点之外，每个节点都有两个子节点，且所有叶子节点都位于同一层次上。这使得理想二叉树具有良好的平衡性。</p>
<h3 id="q_5">Q</h3>
<ol>
<li>In a <strong>complete binary tree</strong> with 1102 nodes, there must be __ leaf nodes. </li>
<li>79</li>
<li>551</li>
<li>1063</li>
<li>cannot be determined</li>
<li>n 为偶数，leaf nodes 的数量=$n/2$; n 为奇数，leaf nodes 的数量=$(n+1)/2$</li>
<li>In-order traversal of a binary tree can be done iteratively. Given the stack operation sequence as the following:<code>push(1), push(2), push(3), pop(), push(4), pop(), pop(), push(5), pop(), pop(), push(6), pop()</code></li>
</ol>
<p>Which one of the following statements is TRUE? </p>
<ol>
<li>6 is the root</li>
<li>2 is the parent of 4</li>
<li>2 and 6 are siblings</li>
<li>None of the above</li>
<li>入栈顺序即为先序遍历的顺序，出栈顺序即为中序遍历的顺序</li>
<li>入栈 123456 出栈 342516</li>
</ol>
<p><img alt="" src="https://cdn.nlark.com/yuque/0/2023/jpeg/34417153/1700392949346-f92b8a12-a863-431a-83a0-d0ad89861e3d.jpeg" /><br />re
<div class="highlight"><pre><span></span><code><span class="n">Tree</span><span class="w"> </span><span class="nf">BuildTree</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">in</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">pre</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span><span class="w"> </span><span class="c1">//in[] stores the inorder traversal sequence</span>
<span class="c1">//and pre[] stores the preorder traversal sequence</span>
<span class="c1">//N is the number of nodes in the tree</span>
<span class="w">    </span><span class="n">Tree</span><span class="w"> </span><span class="n">T</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Tree</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span><span class="p">));</span>
<span class="w">    </span><span class="n">T</span><span class="o">-&gt;</span><span class="n">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pre</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">Data</span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="n">T</span><span class="o">-&gt;</span><span class="n">Left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BuildTree</span><span class="p">(</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">pre</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="n">T</span><span class="o">-&gt;</span><span class="n">Right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BuildTree</span><span class="p">(</span><span class="w"> </span><span class="n">in</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">pre</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">-</span><span class="n">i</span><span class="mi">-1</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">T</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<div class="highlight"><pre><span></span><code><span class="n">Tree</span><span class="w"> </span><span class="nf">BuildTree</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">in</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">post</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="n">Tree</span><span class="w"> </span><span class="n">T</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Tree</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span><span class="p">));</span>
<span class="w">    </span><span class="n">T</span><span class="o">-&gt;</span><span class="n">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">post</span><span class="p">[</span><span class="n">N</span><span class="mi">-1</span><span class="p">];</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">Data</span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="n">T</span><span class="o">-&gt;</span><span class="n">Left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BuildTree</span><span class="p">(</span><span class="w"> </span><span class="n">in</span><span class="p">,</span><span class="w"> </span><span class="n">post</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="n">T</span><span class="o">-&gt;</span><span class="n">Right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BuildTree</span><span class="p">(</span><span class="w"> </span><span class="n">in</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">post</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">N</span><span class="o">-</span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">T</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="heap">堆 Heap 优先队列</h2>
<p>堆序性 heap order</p>
<ul>
<li>the nodes along the path from the root to any node are in sorted order</li>
</ul>
<p>二叉堆 binary heap 是完全填满的二叉树 complete binary tree<br />节点数 $2^h$~$2^h-1$<br />高度 h $⌊logN⌋$<br />父亲在$⌊i/2⌋$位置上</p>
<h4 id="insert_1">Insert</h4>
<h5 id="percolate-up">上滤 percolate up</h5>
<p>在下一个空的位置建一个空穴，向根的方向上走，直到能放入 X</p>
<h4 id="deletemin">DeleteMin</h4>
<h5 id="percolate-down">下滤 percolate down</h5>
<p>将删除元素中儿子的较小值放入空穴，空穴下移一层，重复操作，直到最后一个元素放到正确的位置上（要满足完全二叉树）</p>
<h4 id="build">Build</h4>
<p>用 Insert O(N)</p>
<h4 id="increasekey">IncreaseKey</h4>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">IncreaseKey</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">D</span><span class="p">,</span><span class="w"> </span><span class="n">PriorityQueue</span><span class="w"> </span><span class="n">H</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">   </span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">H</span><span class="o">-&gt;</span><span class="n">Elements</span><span class="p">[</span><span class="n">P</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">D</span><span class="p">;</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">P</span><span class="p">;</span><span class="w"> </span><span class="n">H</span><span class="o">-&gt;</span><span class="n">Elements</span><span class="p">[</span><span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">key</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">/=</span><span class="mi">2</span><span class="w"> </span><span class="p">)</span><span class="w">     </span>
<span class="w">        </span><span class="n">H</span><span class="o">-&gt;</span><span class="n">element</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">H</span><span class="o">-&gt;</span><span class="n">Element</span><span class="p">[</span><span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">];</span>
<span class="w">   </span><span class="n">H</span><span class="o">-&gt;</span><span class="n">Elements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="decreasekey">DecreaseKey</h4>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">DecreaseKey</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">P</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">D</span><span class="p">,</span><span class="w"> </span><span class="n">PriorityQueue</span><span class="w"> </span><span class="n">H</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="w">    </span><span class="n">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">H</span><span class="o">-&gt;</span><span class="n">Elements</span><span class="p">[</span><span class="n">P</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">D</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">P</span><span class="p">;</span><span class="w"> </span><span class="n">H</span><span class="o">-&gt;</span><span class="n">Elements</span><span class="p">[</span><span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">key</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">/=</span><span class="mi">2</span><span class="w"> </span><span class="p">)</span>
<span class="w">        </span><span class="n">H</span><span class="o">-&gt;</span><span class="n">Elements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">H</span><span class="o">-&gt;</span><span class="n">Elements</span><span class="p">[</span><span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="n">H</span><span class="o">-&gt;</span><span class="n">Elements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="relation">关系 Relation</h2>
<h3 id="equivalence-relation">等价关系 equivalence relation</h3>
<ul>
<li>自反性 reflexive</li>
<li>对称性 symmetric</li>
<li>传递性 transitive</li>
</ul>
<p>eg. 相似、模运算、图像连通性</p>
<h4 id="equivalence-class">等价类 equivalence class</h4>
<p>对于 集合 S 有 n 个元素，等价类 equivalence class 数量 x， 有 1≤x≤n 个<br />等价类形成对 S 的一个划分：S 的每个成员恰好出现在一个等价类中</p>
<p>不相交 disjoint</p>
<h3 id="unionfind">Union/Find 算法（并查算法）</h3>
<p>array[] 中每个元素存的是它的根节点的值<br /><a href="https://www.geeksforgeeks.org/introduction-to-disjoint-set-data-structure-or-union-find-algorithm/">Introduction to Disjoint Set (Union-Find Algorithm) - GeeksforGeeks</a></p>
<h4 id="find">Find</h4>
<p>Find(i) O(X)与 X 节点的深度成正比 返回等价类名字（当且仅当两个元素属于相同集合时，Find 返回相同名字
<div class="highlight"><pre><span></span><code><span class="c1">// Finds the representative of the set</span>
<span class="c1">// that i is an element of</span>
<span class="cp">#include</span><span class="cpf">&lt;bits/stdc++.h&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// If i is the parent of itself</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Then i is the representative of</span>
<span class="w">        </span><span class="c1">// this set</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Else if i is not the parent of</span>
<span class="w">        </span><span class="c1">// itself, then i is not the</span>
<span class="w">        </span><span class="c1">// representative of his set. So we</span>
<span class="w">        </span><span class="c1">// recursively call Find on its parent</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">// The code is contributed by Nidhi goel</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">Find</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">ElementType</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">DisjSet</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span><span class="w">   </span>
<span class="w">    </span><span class="n">ElementType</span><span class="w"> </span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">trail</span><span class="p">,</span><span class="w"> </span><span class="n">lead</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="p">;</span><span class="w"> </span><span class="n">S</span><span class="p">[</span><span class="n">root</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">root</span><span class="o">=</span><span class="n">S</span><span class="p">[</span><span class="n">root</span><span class="p">])</span><span class="w"> </span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">trail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="p">;</span><span class="w"> </span><span class="n">trail</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">root</span><span class="p">;</span><span class="w"> </span><span class="n">trail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lead</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">lead</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S</span><span class="p">[</span><span class="n">trail</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w">   </span>
<span class="w">        </span><span class="n">S</span><span class="p">[</span><span class="n">trail</span><span class="p">]</span><span class="o">=</span><span class="n">root</span><span class="p">;</span><span class="w">   </span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">root</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<h4 id="union">Union</h4>
<p>Union(a,b) Θ(N) 将 a 和 b 两个等价类合并成一个新的等价类<br />Union(a,b)后新的根是 a
<div class="highlight"><pre><span></span><code><span class="c1">// Unites the set that includes i</span>
<span class="c1">// and the set that includes j</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;bits/stdc++.h&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">union</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Find the representatives</span>
<span class="w">    </span><span class="c1">// (or the root nodes) for the set</span>
<span class="w">    </span><span class="c1">// that includes i</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">irep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">Find</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
<span class="w">    </span><span class="c1">// And do the same for the set</span>
<span class="w">    </span><span class="c1">// that includes j</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">jrep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">Find</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Make the parent of i’s representative</span>
<span class="w">    </span><span class="c1">// be j’s representative effectively</span>
<span class="w">    </span><span class="c1">// moving all of i’s set into j’s set)</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="n">Parent</span><span class="p">[</span><span class="n">irep</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jrep</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></p>
<h5 id="union-by-size">union-by-size 按大小求并</h5>
<p>小的并到大的上<br />任何节点的深度 depth 不会超过$log(N)$<br />$height(T)≤⌊log_2 N⌋ +1$</p>
<h5 id="union-by-height">union-by-height 按高度求并</h5>
<p>任何节点的深度 depth ≤ 不会超过$log(N)$</p>
<h4 id="path-compression">路径压缩 path compression</h4>
<p>在 Find 操作中执行， 从 X 到根的路径上的每一个节点都使它的父节点变成根，即 使 S[X] 的值等于 Find 返回的值<br />路径压缩与按大小求并完全兼容
<div class="highlight"><pre><span></span><code><span class="n">SetType</span><span class="w"> </span><span class="nf">Find</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">ElementType</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">DisjSet</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span><span class="w">   </span>
<span class="w">   </span><span class="n">ElementType</span><span class="w"> </span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">trail</span><span class="p">,</span><span class="w"> </span><span class="n">lead</span><span class="p">;</span>

<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="p">;</span><span class="w"> </span><span class="n">S</span><span class="p">[</span><span class="n">root</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">root</span><span class="o">=</span><span class="n">S</span><span class="p">[</span><span class="n">root</span><span class="p">])</span><span class="w"> </span><span class="p">;</span><span class="w">  </span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">trail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="p">;</span><span class="w"> </span><span class="n">trail</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">root</span><span class="p">;</span><span class="w"> </span><span class="n">trail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lead</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">lead</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">S</span><span class="p">[</span><span class="n">trail</span><span class="p">]</span><span class="w"> </span><span class="p">;</span><span class="w">   </span>
<span class="w">      </span><span class="n">S</span><span class="p">[</span><span class="n">trail</span><span class="p">]</span><span class="o">=</span><span class="n">root</span><span class="p">;</span><span class="w">   </span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">root</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="c1">//The function BuildMinHeap(H, K) is to arrange elements H[1] ... H[K] into a min-heap. </span>
<span class="c1">//Please complete the following program.</span>

<span class="n">ElementType</span><span class="w"> </span><span class="nf">FindKthLargest</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">A</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">K</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span><span class="w">   </span><span class="cm">/* it is assumed that K&lt;=N */</span>
<span class="w">    </span><span class="n">ElementType</span><span class="w"> </span><span class="o">*</span><span class="n">H</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">child</span><span class="p">;</span>

<span class="w">    </span><span class="n">H</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">ElementType</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">((</span><span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ElementType</span><span class="p">));</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;=</span><span class="n">K</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">];</span>
<span class="w">    </span><span class="n">BuildMinHeap</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">next</span><span class="o">=</span><span class="n">K</span><span class="p">;</span><span class="w"> </span><span class="n">next</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="n">next</span><span class="o">++</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">next</span><span class="p">];</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">&lt;=</span><span class="n">K</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">child</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">child</span><span class="o">!=</span><span class="n">K</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">H</span><span class="p">[</span><span class="n">child</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">H</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">child</span><span class="o">++</span><span class="p">;</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">H</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="w"> </span><span class="p">)</span>
<span class="w">                    </span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">H</span><span class="p">[</span><span class="n">child</span><span class="p">];</span>
<span class="w">                </span><span class="k">else</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">H</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></p>
<h3 id="q_6">Q</h3>
<ol>
<li>The array representation of a disjoint set is given by { 4, 6, 5, 2, -3, -4, 3 }. If the elements are numbered from 1 to 7, the resulting array after invoking <code>Union(Find(7),Find(1))</code> with <strong>union-by-size</strong> and <strong>path-compression</strong> is: </li>
<li>{ 4, 6, 5, 2, 6, -7, 3 }</li>
<li>{ 4, 6, 5, 2, -7, 5, 3 }</li>
<li>{ 6, 6, 5, 6, -7, 5, 5 }</li>
<li>{ 6, 6, 5, 6, 6, -7, 5 }</li>
</ol>
<h5 id="_5"></h5>
<h2 id="graph">图 Graph</h2>
<h3 id="introduction">introduction</h3>
<p>In a directed graph, the sum of the in-degrees and out-degrees of all the vertices is twice the total number of edges.<br />求和 degree=2<em>E<br /></em><em>有最多的边的数量有向图是 n(n-1) ,无向图是 n(n-1) /2</em>*</p>
<h4 id="connected">connected</h4>
<p>There are <strong>n</strong> vertices. <br />The <strong>minimum</strong> number of edges in a <strong>connected graph</strong> is <strong>(n-1). The maximum </strong>for this question is<strong> (n-1) (n-2)/2 + 1</strong>. This is because (n-1) edges can be connected by maximum (n-1) (n-2)/2 edges, and 1 edge to connect to the lonely vertex.</p>
<h4 id="articulation-pointcut-vertex">割点 articulation point/cut vertex</h4>
<p><em>A vertex</em><strong><em> v </em></strong><em>is an </em><strong><em>articulation point </em></strong><em>(also called cut vertex) if removing </em><strong><em>v</em></strong><em> increases the number of connected components.</em></p>
<h3 id="topological">拓扑排序 topological</h3>
<p>对有向无圈图的顶点的一种排序</p>
<h3 id="dijkstra-algorithm">Dijkstra algorithm</h3>
<p>找到从一个给定点到所有点之间的最短路径<br />时间复杂度：$O(|E|+|V|^2)$</p>
<h3 id="maximum-network-flow">Maximum Network Flow  最大网络流</h3>
<p>给定一个表示流网络的图，其中每条边都有容量。还给定图中的两个顶点源“s”和汇“t”，在以下约束下找到从 s 到 t 的最大可能流量：  </p>
<ol>
<li>边缘上的流量不会超过边缘的给定容量。</li>
<li>对于除 s 和 t 之外的每个顶点，传入流等于传出流。</li>
</ol>
<h4 id="dinic">Dinic</h4>
<p><a href="https://www.geeksforgeeks.org/dinics-algorithm-maximum-flow/">Dinic’s algorithm for Maximum Flow - GeeksforGeeks</a><br />Dinic 的算法使用以下概念： </p>
<ol>
<li><em>将残差图 G 初始化为给定图。</em></li>
<li><em>对 G 进行 BFS 来构造一个级别图（或将级别分配给顶点），并检查是否可以有更多流。</em></li>
<li><em>如果无法获得更多流量，则返回</em></li>
<li><em>使用级别图在 G 中发送多个流，直到达到 <strong>阻塞流。</strong>_这里<strong>使用级别图</strong>意味着，在每个流中，从 s 到 t，路径节点的级别应该是 0、1、2…（按顺序）。</em></li>
</ol>
<p>时间复杂度 $O(EV^2)$
<div class="highlight"><pre><span></span><code><span class="c1">// C++ implementation of Dinic&#39;s Algorithm</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;bits/stdc++.h&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="c1">// A structure to represent a edge between</span>
<span class="c1">// two vertex</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Edge</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">;</span><span class="w"> </span><span class="c1">// Vertex v (or &quot;to&quot; vertex)</span>
<span class="w">        </span><span class="c1">// of a directed edge u-v. &quot;From&quot;</span>
<span class="w">        </span><span class="c1">// vertex u can be obtained using</span>
<span class="w">        </span><span class="c1">// index in adjacent array.</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">flow</span><span class="p">;</span><span class="w"> </span><span class="c1">// flow of data in edge</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">C</span><span class="p">;</span><span class="w"> </span><span class="c1">// capacity</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">rev</span><span class="p">;</span><span class="w"> </span><span class="c1">// To store index of reverse</span>
<span class="w">            </span><span class="c1">// edge in adjacency list so that</span>
<span class="w">            </span><span class="c1">// we can quickly find it.</span>
<span class="p">};</span>

<span class="c1">// Residual Graph</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Graph</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">V</span><span class="p">;</span><span class="w"> </span><span class="c1">// number of vertex</span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">level</span><span class="p">;</span><span class="w"> </span><span class="c1">// stores level of a node</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">adj</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Graph</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">V</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">adj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;</span><span class="p">[</span><span class="n">V</span><span class="p">];</span>
<span class="w">        </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V</span><span class="p">;</span>
<span class="w">        </span><span class="n">level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="n">V</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// add edge to the graph</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">addEdge</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">C</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Forward edge : 0 flow and C capacity</span>
<span class="w">        </span><span class="n">Edge</span><span class="w"> </span><span class="n">a</span><span class="p">{</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="p">};</span>

<span class="w">        </span><span class="c1">// Back edge : 0 flow and 0 capacity</span>
<span class="w">        </span><span class="n">Edge</span><span class="w"> </span><span class="n">b</span><span class="p">{</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="p">};</span>

<span class="w">        </span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">        </span><span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="c1">// reverse edge</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">BFS</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">sendFlow</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flow</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ptr</span><span class="p">[]);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">DinicMaxflow</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">// Finds if more flow can be sent from s to t.</span>
<span class="c1">// Also assigns levels to nodes.</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">Graph::BFS</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">V</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">level</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="w">    </span><span class="n">level</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Level of source vertex</span>

<span class="w">    </span><span class="c1">// Create a queue, enqueue source vertex</span>
<span class="w">    </span><span class="c1">// and mark source vertex as visited here</span>
<span class="w">    </span><span class="c1">// level[] array works as visited array also.</span>
<span class="w">    </span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">q</span><span class="p">;</span>
<span class="w">    </span><span class="n">q</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
<span class="w">        </span><span class="n">q</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Edge</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">level</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">flow</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">C</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// Level of current vertex is,</span>
<span class="w">                </span><span class="c1">// level of parent + 1</span>
<span class="w">                </span><span class="n">level</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">level</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">                </span><span class="n">q</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">v</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// IF we can not reach to the sink we</span>
<span class="w">    </span><span class="c1">// return false else true</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">level</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// A DFS based function to send flow after BFS has</span>
<span class="c1">// figured out that there is a possible flow and</span>
<span class="c1">// constructed levels. This function called multiple</span>
<span class="c1">// times for a single call of BFS.</span>
<span class="c1">// flow : Current flow send by parent function call</span>
<span class="c1">// start[] : To keep track of next edge to be explored.</span>
<span class="c1">//       start[i] stores count of edges explored</span>
<span class="c1">//       from i.</span>
<span class="c1">// u : Current vertex</span>
<span class="c1">// t : Sink</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">Graph::sendFlow</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flow</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Sink reached</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">u</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">t</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">flow</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Traverse all adjacent edges one -by - one.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;</span><span class="w"> </span><span class="n">start</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="n">start</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Pick next edge from adjacency list of u</span>
<span class="w">        </span><span class="n">Edge</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">start</span><span class="p">[</span><span class="n">u</span><span class="p">]];</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">level</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">level</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">flow</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">C</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// find minimum flow from u to t</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">curr_flow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">C</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">flow</span><span class="p">);</span>

<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">temp_flow</span>
<span class="w">                </span><span class="o">=</span><span class="w"> </span><span class="n">sendFlow</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">curr_flow</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">);</span>

<span class="w">            </span><span class="c1">// flow is greater than zero</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">temp_flow</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// add flow to current edge</span>
<span class="w">                </span><span class="n">e</span><span class="p">.</span><span class="n">flow</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">temp_flow</span><span class="p">;</span>

<span class="w">                </span><span class="c1">// subtract flow from reverse edge</span>
<span class="w">                </span><span class="c1">// of current edge</span>
<span class="w">                </span><span class="n">adj</span><span class="p">[</span><span class="n">e</span><span class="p">.</span><span class="n">v</span><span class="p">][</span><span class="n">e</span><span class="p">.</span><span class="n">rev</span><span class="p">].</span><span class="n">flow</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">temp_flow</span><span class="p">;</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">temp_flow</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Returns maximum flow in graph</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">Graph::DinicMaxflow</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Corner case</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">t</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">total</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Initialize result</span>

<span class="w">    </span><span class="c1">// Augment the flow while there is path</span>
<span class="w">    </span><span class="c1">// from source to sink</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">BFS</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// store how many edges are visited</span>
<span class="w">        </span><span class="c1">// from V { 0 to V }</span>
<span class="w">        </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="n">V</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]{</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">};</span>

<span class="w">        </span><span class="c1">// while flow is not zero in graph from S to D</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">flow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sendFlow</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">INT_MAX</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>

<span class="w">            </span><span class="c1">// Add path flow to overall flow</span>
<span class="w">            </span><span class="n">total</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">flow</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Remove allocated array</span>
<span class="w">        </span><span class="k">delete</span><span class="p">[]</span><span class="w"> </span><span class="n">start</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// return maximum flow</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">total</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Driver Code</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Graph</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
<span class="w">    </span><span class="n">g</span><span class="p">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">);</span>
<span class="w">    </span><span class="n">g</span><span class="p">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">);</span>
<span class="w">    </span><span class="n">g</span><span class="p">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="n">g</span><span class="p">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">);</span>
<span class="w">    </span><span class="n">g</span><span class="p">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">    </span><span class="n">g</span><span class="p">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">14</span><span class="p">);</span>
<span class="w">    </span><span class="n">g</span><span class="p">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">);</span>
<span class="w">    </span><span class="n">g</span><span class="p">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">);</span>
<span class="w">    </span><span class="n">g</span><span class="p">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span>
<span class="w">    </span><span class="n">g</span><span class="p">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// next exmp</span>
<span class="w">    </span><span class="cm">/*g.addEdge(0, 1, 3 );</span>
<span class="cm">    g.addEdge(0, 2, 7 ) ;</span>
<span class="cm">    g.addEdge(1, 3, 9);</span>
<span class="cm">    g.addEdge(1, 4, 9 );</span>
<span class="cm">    g.addEdge(2, 1, 9 );</span>
<span class="cm">    g.addEdge(2, 4, 9);</span>
<span class="cm">    g.addEdge(2, 5, 4);</span>
<span class="cm">    g.addEdge(3, 5, 3);</span>
<span class="cm">    g.addEdge(4, 5, 7 );</span>
<span class="cm">    g.addEdge(0, 4, 10);</span>

<span class="cm">    // next exp</span>
<span class="cm">    g.addEdge(0, 1, 10);</span>
<span class="cm">    g.addEdge(0, 2, 10);</span>
<span class="cm">    g.addEdge(1, 3, 4 );</span>
<span class="cm">    g.addEdge(1, 4, 8 );</span>
<span class="cm">    g.addEdge(1, 2, 2 );</span>
<span class="cm">    g.addEdge(2, 4, 9 );</span>
<span class="cm">    g.addEdge(3, 5, 10 );</span>
<span class="cm">    g.addEdge(4, 3, 6 );</span>
<span class="cm">    g.addEdge(4, 5, 10 ); */</span>

<span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Maximum flow &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">DinicMaxflow</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
Ford-</p>
<h3 id="mst">MST 最小生成树</h3>
<p>最小生成树(MST) 或带权连通无向图的最小权重生成树是权重小于或等于所有其他生成树权重的生成树。</p>
<h4 id="necessary-and-sufficient-condition-for-unique-mst">Necessary-And-Sufficient-Condition-for-Unique-MST</h4>
<p><a href="https://rivers-shall.github.io/2018/11/19/Necessary-And-Sufficient-Condition-for-Unique-MST/">Necessary-And-Sufficient-Condition-for-Unique-MST</a><br />Let <em>𝐺 _be a connecte d weighted graph and _𝑇</em> a minimum spanning tree of <em>𝐺</em>. Show that <em>𝑇</em> is a unique minimum spanning tree <strong>if and only if</strong> the weight of each edge <em>𝑒 _of _𝐺</em> that is not in <em>𝑇</em> exceeds the weight of every other edge on the cycle in <em>𝑇</em>+<em>𝑒 </em>.</p>
<ol>
<li><strong>Existence of Minimum Spanning Tree (MST):</strong></li>
<li>If the graph is connected, a minimum spanning tree always exists.</li>
<li>For an undirected connected graph, the minimum spanning tree is a subset of edges that forms a tree connecting all vertices with the minimum possible total edge weight.</li>
<li><strong>Conditions for Existence:</strong></li>
<li>In a connected graph, a minimum spanning tree is guaranteed.</li>
<li>If the graph is not connected, there won't be a minimum spanning tree [<a href="https://zhuanlan.zhihu.com/p/52475302">4</a>].</li>
<li><strong>Algorithms:</strong></li>
<li>Kruskal's and Prim's algorithms are commonly used to find the minimum spanning tree of a connected graph.</li>
</ol>
<h4 id="prim">Prim 算法</h4>
<p>从已经在 MST 里面的顶点中，连接未在 MST 中的顶点，使其边权最小<br /><strong><em>Step 1:</em></strong><em> Determine an arbitrary vertex as the starting vertex of the MST.</em><br /><strong><em>Step 2:</em></strong><em> Follow steps 3 to 5 till there are vertices that are not included in the MST (known as fringe vertex).</em><br /><strong><em>Step 3:</em></strong><em> Find edges connecting any tree vertex with the fringe vertices.</em><br /><strong><em>Step 4:</em></strong><em> Find the minimum among these edges.</em><br /><strong><em>Step 5:</em></strong><em> Add the chosen edge to the MST if it does not form any cycle.</em><br /><strong><em>Step 6:</em></strong><em> Return the MST and exit</em>
<div class="highlight"><pre><span></span><code><span class="c1">// A C program for Prim&#39;s Minimum</span>
<span class="c1">// Spanning Tree (MST) algorithm. The program is</span>
<span class="c1">// for adjacency matrix representation of the graph</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;limits.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdbool.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="c1">// Number of vertices in the graph</span>
<span class="cp">#define V 5</span>

<span class="c1">// A utility function to find the vertex with</span>
<span class="c1">// minimum key value, from the set of vertices</span>
<span class="c1">// not yet included in MST</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">minKey</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">key</span><span class="p">[],</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">mstSet</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Initialize min value</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INT_MAX</span><span class="p">,</span><span class="w"> </span><span class="n">min_index</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">V</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mstSet</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">key</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">min</span><span class="p">)</span>
<span class="w">            </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">key</span><span class="p">[</span><span class="n">v</span><span class="p">],</span><span class="w"> </span><span class="n">min_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">min_index</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// A utility function to print the</span>
<span class="c1">// constructed MST stored in parent[]</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">printMST</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">parent</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">graph</span><span class="p">[</span><span class="n">V</span><span class="p">][</span><span class="n">V</span><span class="p">])</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Edge </span><span class="se">\t</span><span class="s">Weight</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">V</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d - %d </span><span class="se">\t</span><span class="s">%d </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">i</span><span class="p">,</span>
<span class="w">            </span><span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]]);</span>
<span class="p">}</span>

<span class="c1">// Function to construct and print MST for</span>
<span class="c1">// a graph represented using adjacency</span>
<span class="c1">// matrix representation</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">primMST</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">graph</span><span class="p">[</span><span class="n">V</span><span class="p">][</span><span class="n">V</span><span class="p">])</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Array to store constructed MST</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">parent</span><span class="p">[</span><span class="n">V</span><span class="p">];</span>
<span class="w">    </span><span class="c1">// Key values used to pick minimum weight edge in cut</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">key</span><span class="p">[</span><span class="n">V</span><span class="p">];</span>
<span class="w">    </span><span class="c1">// To represent set of vertices included in MST</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">mstSet</span><span class="p">[</span><span class="n">V</span><span class="p">];</span>

<span class="w">    </span><span class="c1">// Initialize all keys as INFINITE</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">V</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INT_MAX</span><span class="p">,</span><span class="w"> </span><span class="n">mstSet</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Always include first 1st vertex in MST.</span>
<span class="w">    </span><span class="c1">// Make key 0 so that this vertex is picked as first</span>
<span class="w">    </span><span class="c1">// vertex.</span>
<span class="w">    </span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// First node is always root of MST</span>
<span class="w">    </span><span class="n">parent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// The MST will have V vertices</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">count</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="c1">// Pick the minimum key vertex from the</span>
<span class="w">        </span><span class="c1">// set of vertices not yet included in MST</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">minKey</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">mstSet</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Add the picked vertex to the MST Set</span>
<span class="w">        </span><span class="n">mstSet</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Update key value and parent index of</span>
<span class="w">        </span><span class="c1">// the adjacent vertices of the picked vertex.</span>
<span class="w">        </span><span class="c1">// Consider only those vertices which are not</span>
<span class="w">        </span><span class="c1">// yet included in MST</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">V</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="o">++</span><span class="p">)</span>

<span class="w">            </span><span class="c1">// graph[u][v] is non zero only for adjacent</span>
<span class="w">            </span><span class="c1">// vertices of m mstSet[v] is false for vertices</span>
<span class="w">            </span><span class="c1">// not yet included in MST Update the key only</span>
<span class="w">            </span><span class="c1">// if graph[u][v] is smaller than key[v]</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">mstSet</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span>
<span class="w">                </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">key</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
<span class="w">                </span><span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// print the constructed MST</span>
<span class="w">    </span><span class="n">printMST</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="n">graph</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Driver&#39;s code</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">graph</span><span class="p">[</span><span class="n">V</span><span class="p">][</span><span class="n">V</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span>
<span class="w">                        </span><span class="p">{</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">},</span>
<span class="w">                        </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="p">},</span>
<span class="w">                        </span><span class="p">{</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="p">},</span>
<span class="w">                        </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// Print the solution</span>
<span class="w">    </span><span class="n">primMST</span><span class="p">(</span><span class="n">graph</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
时间复杂度：$O(V^2)$，如果输入图使用邻接表来表示，那么借助二叉堆，Prim算法的时间复杂度可以降低到$O(E * logV)$。在这个实现中，我们总是考虑生成树从图的根开始<br />空间：$O(V)$</p>
<h4 id="kruskal">Kruskal 算法</h4>
<p><a href="https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/">Kruskal’s Minimum Spanning Tree (MST) Algorithm - GeeksforGeeks</a><br />在克鲁斯卡尔算法中，按升序对给定图的所有边进行排序。如果新添加的边不形成环，则继续在MST中添加新的边和节点。它首先选择<strong>最小加权边</strong>，最后选择最大加权边。因此我们可以说它在每一步中都做出局部最优选择以找到最优解。因此这是一个<a href="https://www.geeksforgeeks.org/introduction-to-greedy-algorithm-data-structures-and-algorithm-tutorials/">贪婪算法</a>。</p>
<ol>
<li>按权重非降序对所有边进行排序。 </li>
<li>选择最小的边。检查是否与目前形成的生成树形成环。如果未形成循环，则包括该边。否则，丢弃它。 </li>
<li>
<p>重复步骤2，直到生成树中有 (V-1) 条边。
<div class="highlight"><pre><span></span><code><span class="c1">// C++ program for the above approach </span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="c1"> </span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span><span class="w"> </span>

<span class="c1">// DSU data structure </span>
<span class="c1">// path compression + rank by union </span>
<span class="k">class</span><span class="w"> </span><span class="nc">DSU</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">parent</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">rank</span><span class="p">;</span><span class="w"> </span>

<span class="k">public</span><span class="o">:</span><span class="w"> </span>
<span class="w">    </span><span class="n">DSU</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="n">parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">];</span><span class="w"> </span>
<span class="w">        </span><span class="n">rank</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">];</span><span class="w"> </span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">            </span><span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span>
<span class="w">            </span><span class="n">rank</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span>

<span class="w">    </span><span class="c1">// Find function </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"> </span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span>

<span class="w">    </span><span class="c1">// Union function </span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">unite</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span><span class="w"> </span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s1</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">s2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rank</span><span class="p">[</span><span class="n">s2</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">                </span><span class="n">parent</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s2</span><span class="p">;</span><span class="w"> </span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rank</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">rank</span><span class="p">[</span><span class="n">s2</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">                </span><span class="n">parent</span><span class="p">[</span><span class="n">s2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span><span class="w"> </span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">                </span><span class="n">parent</span><span class="p">[</span><span class="n">s2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span><span class="w"> </span>
<span class="w">                </span><span class="n">rank</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span>
<span class="p">};</span><span class="w"> </span>

<span class="k">class</span><span class="w"> </span><span class="nc">Graph</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">edgelist</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">V</span><span class="p">;</span><span class="w"> </span>

<span class="k">public</span><span class="o">:</span><span class="w"> </span>
<span class="w">    </span><span class="n">Graph</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">V</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">V</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span>

<span class="w">    </span><span class="c1">// Function to add edge in a graph </span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">addEdge</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="n">edgelist</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="p">});</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">kruskals_mst</span><span class="p">()</span><span class="w"> </span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span>
<span class="w">        </span><span class="c1">// Sort all edges </span>
<span class="w">        </span><span class="n">sort</span><span class="p">(</span><span class="n">edgelist</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">edgelist</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="w"> </span><span class="c1">//边排序</span>

<span class="w">        </span><span class="c1">// Initialize the DSU </span>
<span class="w">        </span><span class="n">DSU</span><span class="w"> </span><span class="nf">s</span><span class="p">(</span><span class="n">V</span><span class="p">);</span><span class="w"> </span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">ans</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Following are the edges in the &quot;</span>
<span class="w">                </span><span class="s">&quot;constructed MST&quot;</span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">edgelist</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span><span class="w"> </span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"> </span>

<span class="w">            </span><span class="c1">// Take this edge in MST if it does </span>
<span class="w">            </span><span class="c1">// not forms a cycle </span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">                </span><span class="n">s</span><span class="p">.</span><span class="n">unite</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"> </span>
<span class="w">                </span><span class="n">ans</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">w</span><span class="p">;</span><span class="w"> </span>
<span class="w">                </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; -- &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; == &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">w</span><span class="w"> </span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span><span class="w"> </span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span>
<span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Minimum Cost Spanning Tree: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ans</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span>
<span class="p">};</span><span class="w"> </span>

<span class="c1">// Driver code </span>
<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span>
<span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="n">Graph</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="n">g</span><span class="p">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="n">g</span><span class="p">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="n">g</span><span class="p">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="n">g</span><span class="p">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="n">g</span><span class="p">.</span><span class="n">addEdge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">);</span><span class="w"> </span>

<span class="w">    </span><span class="c1">// Function call </span>
<span class="w">    </span><span class="n">g</span><span class="p">.</span><span class="n">kruskals_mst</span><span class="p">();</span><span class="w"> </span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span>
<span class="p">}</span>
</code></pre></div>
时间复杂度：$O(E * logE)$ 或 $O(E * logV)$ </p>
</li>
<li>
<p>边排序需要 $O(E * logE)$ 时间。 </p>
</li>
<li>排序后，我们迭代所有边并应用查找并集算法。查找和并集操作最多需要 $O(logV)$ 时间。</li>
<li>所以总体复杂度是 $O(E * logE + E * logV)$ 时间。 </li>
<li>E的值最多可以是O(V 2 )，因此O(logV)和O(logE)是相同的。因此，总体时间复杂度为 $O(E * logE)$或 $O(E*logV)$</li>
</ol>
<h3 id="dfs">DFS 深度优先搜索</h3>
<ol>
<li>最初堆栈和访问数组都是空的。</li>
<li>访问某一节点，将其未访问过的相邻节点放入栈中。</li>
<li>访问栈顶并将其从栈中弹出，并将其所有未访问的相邻节点放入栈中。</li>
<li>重复步骤 3 直到栈变空，DFS 结束</li>
</ol>
<h4 id="find-articulation-point">Find articulation point 找割点</h4>
<h4 id="strongly-connected-components">Strongly Connected Components 强连通组件</h4>
<h4 id="tarjan">Tarjan 算法 找割点？还是强连通组件</h4>
<p>DFS+栈实现<br /><a href="https://www.bilibili.com/video/BV19J411J7AZ?p=4&amp;share_source=copy_web">哔哩哔哩视频参考</a>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="cpf">&lt;malloc.h&gt;</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">VNode</span><span class="w"> </span><span class="o">*</span><span class="n">PtrToVNode</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">VNode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Vertex</span><span class="w"> </span><span class="n">Vert</span><span class="p">;</span>
<span class="w">    </span><span class="n">PtrToVNode</span><span class="w"> </span><span class="n">Next</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">GNode</span><span class="w"> </span><span class="o">*</span><span class="n">Graph</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">GNode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">NumOfVertices</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">NumOfEdges</span><span class="p">;</span>
<span class="w">    </span><span class="n">PtrToVNode</span><span class="w"> </span><span class="o">*</span><span class="n">Array</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="cp">#define min(a,b) (((a)&lt;(b))?(a):(b))</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="n">Graph</span><span class="w"> </span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="n">Vertex</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">[],</span><span class="w"> </span><span class="n">PtrToVNode</span><span class="w"> </span><span class="n">stack</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">visited</span><span class="p">[]);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">push</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">PtrToVNode</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">top</span><span class="p">(</span><span class="n">PtrToVNode</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">pop</span><span class="p">(</span><span class="n">PtrToVNode</span><span class="w"> </span><span class="n">s</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">StronglyConnectedComponents</span><span class="p">(</span><span class="w"> </span><span class="n">Graph</span><span class="w"> </span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">visit</span><span class="p">)(</span><span class="n">Vertex</span><span class="w"> </span><span class="n">V</span><span class="p">)</span><span class="w"> </span><span class="p">){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">[</span><span class="n">MaxVertices</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">visited</span><span class="p">[</span><span class="n">MaxVertices</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="p">[</span><span class="n">MaxVertices</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="w">    </span><span class="n">PtrToVNode</span><span class="w"> </span><span class="n">stack</span><span class="p">;</span>
<span class="w">    </span><span class="n">stack</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">VNode</span><span class="p">));</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">G</span><span class="o">-&gt;</span><span class="n">NumOfVertices</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">find</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">num</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">stack</span><span class="p">,</span><span class="n">visited</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="n">Graph</span><span class="w"> </span><span class="n">G</span><span class="p">,</span><span class="w"> </span><span class="n">Vertex</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="p">[],</span><span class="kt">int</span><span class="w"> </span><span class="n">low</span><span class="p">[],</span><span class="w"> </span><span class="n">PtrToVNode</span><span class="w"> </span><span class="n">stack</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">visited</span><span class="p">[]){</span>
<span class="w">    </span><span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">num</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="n">push</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">stack</span><span class="p">);</span>
<span class="w">    </span><span class="n">PtrToVNode</span><span class="w"> </span><span class="n">w</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">Array</span><span class="p">[</span><span class="n">v</span><span class="p">];</span><span class="n">w</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">;</span><span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">){</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">num</span><span class="p">[</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">Vert</span><span class="p">]){</span>
<span class="w">            </span><span class="n">find</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">Vert</span><span class="p">,</span><span class="n">num</span><span class="p">,</span><span class="n">low</span><span class="p">,</span><span class="n">stack</span><span class="p">,</span><span class="n">visited</span><span class="p">);</span>

<span class="w">            </span><span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">],</span><span class="n">low</span><span class="p">[</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">Vert</span><span class="p">]);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">Vert</span><span class="p">]){</span>
<span class="w">                </span><span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">],</span><span class="n">num</span><span class="p">[</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">Vert</span><span class="p">]);</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">==</span><span class="n">low</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="p">){</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="o">!=</span><span class="n">v</span><span class="w"> </span><span class="p">){</span>
<span class="w">                </span><span class="n">t</span><span class="o">=</span><span class="n">top</span><span class="p">(</span><span class="n">stack</span><span class="p">);</span>
<span class="w">                </span><span class="n">pop</span><span class="p">(</span><span class="n">stack</span><span class="p">);</span>
<span class="w">                </span><span class="n">visited</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="w">                </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="n">t</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">push</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">PtrToVNode</span><span class="w"> </span><span class="n">s</span><span class="p">){</span>
<span class="w">    </span><span class="n">PtrToVNode</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="w">    </span><span class="n">tmp</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">VNode</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">tmp</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
<span class="w">        </span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">Vert</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>
<span class="w">        </span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">Next</span><span class="o">=</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
<span class="w">        </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">Next</span><span class="o">=</span><span class="n">tmp</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">top</span><span class="p">(</span><span class="n">PtrToVNode</span><span class="w"> </span><span class="n">s</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">Next</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">Next</span><span class="o">-&gt;</span><span class="n">Vert</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">pop</span><span class="p">(</span><span class="n">PtrToVNode</span><span class="w"> </span><span class="n">s</span><span class="p">){</span>
<span class="w">    </span><span class="n">PtrToVNode</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="n">a</span><span class="o">=</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">VNode</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">Next</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">){</span>
<span class="w">        </span><span class="n">a</span><span class="o">=</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
<span class="w">        </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">Next</span><span class="o">=</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">Next</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
<span class="w">        </span><span class="n">free</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
时间复杂度：$O(E+V)$邻接表；$O(V^2)$邻接矩阵</p>
<h3 id="q_7">Q</h3>
<ol>
<li>If an undirected graph G = (V, E) contains 10 vertices. Then to guarantee that G is connected in any cases, there has to be at least __ edges. ？</li>
<li>45</li>
<li>37</li>
<li>36</li>
<li>9</li>
<li>Which of the following statements is TRUE about <strong>topological sorting</strong>?</li>
<li>If a graph has a topological sequence, then its adjacency matrix must be triangular.</li>
<li>If the adjacency matrix is triangular, then the corresponding directed graph must have a unique topological sequence.</li>
<li>In a DAG, if for any pair of distinct vertices <em>Vi</em> and <em>Vj</em>, there is a path either from <em>Vi</em> to <em>Vj</em> or from <em>Vj</em> to <em>Vi</em>, then the DAG must have a unique topological sequence.</li>
<li>If <em>Vi</em> precedes <em>Vj</em> in a topological sequence, then there must be a path from <em>Vi</em> to <em>V</em></li>
<li>Let P be the shortest path from S to T. If the weight of every edge in the graph is <strong>incremented by 2</strong>, P will still be the <strong>shortest path</strong> from S to T.  <strong>F</strong></li>
</ol>
<p><img alt="image.png" src="https://cdn.nlark.com/yuque/0/2023/png/34417153/1700458094213-1eb94f81-15d1-4298-ace3-94eec187eb84.png#averageHue=%23fcfaf8&amp;clientId=u28924e74-1e87-4&amp;from=paste&amp;height=109&amp;id=u5f235e5e&amp;originHeight=164&amp;originWidth=969&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=33325&amp;status=done&amp;style=none&amp;taskId=u233db402-7e52-4814-8958-733e0fc4db2&amp;title=&amp;width=646" /></p>
<ol>
<li>The minimum spanning tree of any connected weighted graph: 任意连通加权图的最小生成树<br />C.may not be unique</li>
<li>Apply DFS to a directed acyclic graph（有向无圈图）, and output the vertex before the end of each recursion. The output sequence will be:</li>
</ol>
<p>C.reversely topologically sorted</p>
<ol>
<li>Graph G is an undirected completed graph of 20 nodes. Is there an Euler circuit in G? If not, in order to have an <strong>Euler circuit</strong>, what is the minimum number of edges which should be removed from G?</li>
</ol>
<p>Each Node has exactly 19 degrees</p>
<ul>
<li>Euler Circuit (Strong Form) requires every node to be even degrees</li>
<li>Euler Tour (Weak Form) requires 0 or 2 odd degrees</li>
</ul>
<p>Remove 1 edge, every 2 nodes will lose 1 degrees, so we lose<strong> 10 edges</strong></p>
<h3 id="_6"><br /></h3>
<h1 id="questions">Questions</h1>
<h2 id="homework">homework</h2>
<ol>
<li>For a sequentially stored linear list of length N, the time complexities for deleting the first element and inserting the last element are ~~O(1) and O(N)~~, respectively. 
    <strong>F</strong> O(N) and O(1)</li>
<li>顺序存储的线性表支持随机存取，所以查询的时间是常数时间，但插入需要把后面每一个元素的位置都进行调整，所以是线性时间。 插入最后一个时间为O(1).</li>
<li>循环队列满时rear == front -1. enqueue时 rear 增加, dequeue front 增加.</li>
<li>To insert <strong>s</strong> after <strong>p</strong> in a <strong>doubly linked circular list</strong>, we must do: <ul>
<li>A. p-&gt;next=s; s-&gt;prior=p; p-&gt;next-&gt;prior=s ; </li>
<li>B. p-&gt;next-&gt;prior=s; p-&gt;next=s; s-&gt;prior=p; s-&gt;next=p-&gt;next;</li>
<li>C. s-&gt;prior=p; s-&gt;next=p-&gt;next; p-&gt;next=s; p-&gt;next-&gt;prior=s;</li>
<li>D. s-&gt;prior=p; s-&gt;next=p-&gt;next; p-&gt;next-&gt;prior=s; p-&gt;next=s;</li>
</ul>
</li>
<li>It is always possible to represent a tree by a one-dimensional integer array. <strong>T</strong></li>
<li>It is always possible to represent a tree by a one-dimensional integer array using various techniques such as breadth-first or depth-first traversal.</li>
<li>
<p>If a general tree <strong><em>T</em></strong> is converted into a binary tree <em><strong>BT</strong></em>, then which of the following <em>BT</em> traversals gives the same sequence as that of the post-order traversal of <em>T</em>?</p>
<ul>
<li>A. Pre-order traversal</li>
<li>B. In-order traversal</li>
<li>C. Post-order traversal</li>
<li>D. Level-order traversal<br />
T的preorder = BT的preorder<br />T的postorder = BT的inorder</li>
</ul>
</li>
<li>
<p>Among the following <strong>threaded binary trees</strong> (the threads are represented by dotted curves), which one is the <strong>postorde</strong>r threaded tree?</p>
</li>
</ol>
<p><img alt="image.png" src="https://cdn.nlark.com/yuque/0/2023/png/34417153/1697439522870-c8589768-7675-48b9-947a-71152079215b.png#averageHue=%23e9e9e9&amp;clientId=u138eea40-32ac-4&amp;from=paste&amp;height=238&amp;id=u6de5fbca&amp;originHeight=357&amp;originWidth=345&amp;originalType=binary&amp;ratio=1.5&amp;rotation=0&amp;showTitle=false&amp;size=58121&amp;status=done&amp;style=none&amp;taskId=u8da9c0b4-6e22-4f7f-90f7-ac738dc318b&amp;title=&amp;width=230" /><br />线索二叉树中，<strong>左线索为上一个结点，右线索为下一个结点</strong><br />后序：左右根<br />中序：左根右<br />前序：根左右</p>
<ol>
<li>Suppose that an array of size 6 is used to store a circular queue, and the values of front and rear are 0 and 4, respectively. Now after 2 dequeues and 2 enqueues, what will the values of front and rear be?</li>
<li>2 and 0</li>
<li>2 and 2</li>
<li>2 and 4</li>
<li>2 and 6</li>
<li>头是 0 而不是 6</li>
<li>Suppose that an array of size m is used to store a circular queue. If the head pointer front and the current size variable size are used to represent the range of the queue instead of front and rear, then the maximum capacity of this queue can be: (5分)</li>
<li>m-1</li>
<li>m</li>
<li>m+1</li>
<li>cannot be determined</li>
<li>就是数组的大小</li>
</ol>
<h2 id="midterm">Midterm</h2>
<ol>
<li>The time comlexity of Selection Sort will be the same no matter we store the elements in an array or a linked list. <strong>T</strong></li>
<li>If <em>N</em> numbers are stored in a singly linked list in increasing order, then the average time complexity for binary search is <em>O</em>(<em>logN</em>). <strong>F </strong>链表是不能使用折半查找的</li>
<li>The time complexity of Selection Sort will be the same no matter we store the elements in an array or a linked list. <strong>T</strong></li>
<li>If a stack is used to convert the infix expression a+b<em>c+(d</em>e+f)*g into a postfix expression, what will be in the stack (listing from the bottom up) when f is read?</li>
<li>+(+</li>
<li>+(*+</li>
<li>abcde</li>
<li>+<em>+(</em>+</li>
</ol>
<p>中缀表达式转化为后缀表达式，转化的算法如下：</p>
<ul>
<li>初始化一个栈</li>
<li>逐个读取元素（数字或者操作符）</li>
<li>如果遇到数字，直接输出</li>
<li>如果遇到操作符（不考虑括号），<strong>如果其优先级大于栈顶元素，就将栈顶弹出</strong>，并重复此步骤，否则将该操作符压入栈中（栈为空的时候也直接压栈即可）</li>
<li>如果遇到左括号"("，直接将其压入栈中，如果遇到右括号")"，<strong>循环弹出顶栈元素，直到左括号为止</strong>（左括号也需要弹出，右括号不需要压栈），并且输出所有被弹栈顶元素（左括号除外）</li>
<li>Suppose that a polynomial（多项式） is represented by a linked list storing its non-zero terms. Given two polynimials with N1 and N2 non-zero terms, and the highest exponents being M1 and M2, respectively. Then the time complexity for adding them up is:</li>
<li>O(N1×N2)</li>
<li>O(N1+N2)</li>
<li>O(M1×M2)</li>
<li>O(M1+M2)</li>
<li><br /></li>
</ul>
<h2 id="pta-code">Pta code</h2>
<h3 id="true-or-flase">True or Flase</h3>
<p><a href="https://blog.csdn.net/Qian280101/article/details/121874494">算法竞赛基础训练题_判断题_it is always possible to represent a tree by a one_白术_竹苓的博客-CSDN博客</a></p>
<h3 id="function">function</h3>
<p><div class="highlight"><pre><span></span><code><span class="n">List</span><span class="w"> </span><span class="nf">Reverse</span><span class="p">(</span><span class="w"> </span><span class="n">List</span><span class="w"> </span><span class="n">L</span><span class="w"> </span><span class="p">){</span>
<span class="w">    </span><span class="n">List</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="n">node</span><span class="p">,</span><span class="n">temp</span><span class="p">;</span>
<span class="w">    </span><span class="n">node</span><span class="o">=</span><span class="n">L</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">node</span><span class="p">){</span>
<span class="w">        </span><span class="n">temp</span><span class="o">=</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
<span class="w">        </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">Next</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>
<span class="w">        </span><span class="n">head</span><span class="o">=</span><span class="n">node</span><span class="p">;</span>
<span class="w">        </span><span class="n">node</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">L</span><span class="o">-&gt;</span><span class="n">Next</span><span class="o">=</span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">L</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span><span class="w"> </span><span class="o">*</span><span class="n">PtrToNode</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">PtrToNode</span><span class="w"> </span><span class="n">List</span><span class="p">;</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">PtrToNode</span><span class="w"> </span><span class="n">Position</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Node</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ElementType</span><span class="w"> </span><span class="n">Element</span><span class="p">;</span>
<span class="w">    </span><span class="n">Position</span><span class="w"> </span><span class="n">Next</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
The function Reverse is supposed to return the reverse linked list of L, with a dummy header.</p>
<div class="highlight"><pre><span></span><code><span class="n">Polynomial</span><span class="w"> </span><span class="nf">Add</span><span class="p">(</span><span class="w"> </span><span class="n">Polynomial</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">Polynomial</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">){</span>
<span class="w">    </span><span class="n">Polynomial</span><span class="w"> </span><span class="n">head</span><span class="p">,</span><span class="n">temp</span><span class="p">,</span><span class="n">node</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="n">node</span><span class="o">=</span><span class="p">(</span><span class="n">Polynomial</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Polynomial</span><span class="p">));</span>
<span class="w">    </span><span class="n">head</span><span class="o">=</span><span class="n">node</span><span class="p">;</span>
<span class="w">    </span><span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
<span class="w">    </span><span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">a</span><span class="p">){</span>
<span class="w">        </span><span class="n">temp</span><span class="o">=</span><span class="p">(</span><span class="n">Polynomial</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Polynomial</span><span class="p">));</span>

<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">Exponent</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="o">-&gt;</span><span class="n">Exponent</span><span class="p">){</span>
<span class="w">            </span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">Coefficient</span><span class="o">=</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">Coefficient</span><span class="p">;</span>
<span class="w">            </span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">Exponent</span><span class="o">=</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">Exponent</span><span class="p">;</span>
<span class="w">            </span><span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">Exponent</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">a</span><span class="o">-&gt;</span><span class="n">Exponent</span><span class="p">){</span>
<span class="w">            </span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">Coefficient</span><span class="o">=</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">Coefficient</span><span class="p">;</span>
<span class="w">            </span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">Exponent</span><span class="o">=</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">Exponent</span><span class="p">;</span>
<span class="w">            </span><span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="k">else</span><span class="p">{</span>
<span class="w">            </span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">Coefficient</span><span class="o">=</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">Coefficient</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">Coefficient</span><span class="p">;</span>
<span class="w">            </span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">Exponent</span><span class="o">=</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">Exponent</span><span class="p">;</span>
<span class="w">            </span><span class="n">a</span><span class="o">=</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
<span class="w">            </span><span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">Coefficient</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">Next</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">Next</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
<span class="w">        </span><span class="n">node</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">Next</span><span class="o">=</span><span class="n">a</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="n">node</span><span class="o">-&gt;</span><span class="n">Next</span><span class="o">=</span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Node</span><span class="w"> </span><span class="o">*</span><span class="n">PtrToNode</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Node</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">Coefficient</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">Exponent</span><span class="p">;</span>
<span class="w">    </span><span class="n">PtrToNode</span><span class="w"> </span><span class="n">Next</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span><span class="w"> </span><span class="n">PtrToNode</span><span class="w"> </span><span class="n">Polynomial</span><span class="p">;</span>
<span class="cm">/* Nodes are sorted in decreasing order of exponents.*/</span><span class="w">  </span>
</code></pre></div>
<p><div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">Print_NLT</span><span class="p">(</span><span class="w"> </span><span class="n">Tree</span><span class="w"> </span><span class="n">T</span><span class="p">,</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="k">return</span><span class="p">;</span><span class="c1">//如果树为空，返回null</span>

<span class="w">    </span><span class="c1">//直接进行树的遍历，因为是从大到小输出不小于X的数</span>
<span class="w">    </span><span class="c1">//所以先遍历右子树，大于X的直接输出，再遍历左子树.</span>
<span class="w">    </span><span class="n">Print_NLT</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">Right</span><span class="p">,</span><span class="n">X</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">Element</span><span class="o">&gt;=</span><span class="n">X</span><span class="p">){</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">Element</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">Print_NLT</span><span class="p">(</span><span class="n">T</span><span class="o">-&gt;</span><span class="n">Left</span><span class="p">,</span><span class="n">X</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">Isomorphic</span><span class="p">(</span><span class="w"> </span><span class="n">Tree</span><span class="w"> </span><span class="n">T1</span><span class="p">,</span><span class="w"> </span><span class="n">Tree</span><span class="w"> </span><span class="n">T2</span><span class="w"> </span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">T1</span><span class="o">==</span><span class="nb">NULL</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">T2</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">((</span><span class="n">T1</span><span class="o">==</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">T2</span><span class="o">!=</span><span class="nb">NULL</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">T1</span><span class="o">!=</span><span class="nb">NULL</span><span class="o">&amp;&amp;</span><span class="n">T2</span><span class="o">==</span><span class="nb">NULL</span><span class="p">))</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">T1</span><span class="o">-&gt;</span><span class="n">Element</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">T2</span><span class="o">-&gt;</span><span class="n">Element</span><span class="p">)</span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">Isomorphic</span><span class="p">(</span><span class="n">T1</span><span class="o">-&gt;</span><span class="n">Left</span><span class="p">,</span><span class="n">T2</span><span class="o">-&gt;</span><span class="n">Left</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="n">Isomorphic</span><span class="p">(</span><span class="n">T1</span><span class="o">-&gt;</span><span class="n">Right</span><span class="p">,</span><span class="n">T2</span><span class="o">-&gt;</span><span class="n">Right</span><span class="p">))</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">Isomorphic</span><span class="p">(</span><span class="n">T1</span><span class="o">-&gt;</span><span class="n">Right</span><span class="p">,</span><span class="n">T2</span><span class="o">-&gt;</span><span class="n">Left</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="n">Isomorphic</span><span class="p">(</span><span class="n">T1</span><span class="o">-&gt;</span><span class="n">Left</span><span class="p">,</span><span class="n">T2</span><span class="o">-&gt;</span><span class="n">Right</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">PercolateUp</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">PriorityQueue</span><span class="w"> </span><span class="n">H</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">H</span><span class="o">-&gt;</span><span class="n">Elements</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">H</span><span class="o">-&gt;</span><span class="n">Elements</span><span class="p">[</span><span class="n">p</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>
<span class="w">        </span><span class="n">temp</span><span class="o">=</span><span class="n">H</span><span class="o">-&gt;</span><span class="n">Elements</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
<span class="w">        </span><span class="n">H</span><span class="o">-&gt;</span><span class="n">Elements</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">=</span><span class="n">H</span><span class="o">-&gt;</span><span class="n">Elements</span><span class="p">[</span><span class="n">p</span><span class="o">/</span><span class="mi">2</span><span class="p">];</span>
<span class="w">        </span><span class="n">H</span><span class="o">-&gt;</span><span class="n">Elements</span><span class="p">[</span><span class="n">p</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
<span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">/=</span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">PercolateDown</span><span class="p">(</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">PriorityQueue</span><span class="w"> </span><span class="n">H</span><span class="w"> </span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">H</span><span class="o">-&gt;</span><span class="n">Elements</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">H</span><span class="o">-&gt;</span><span class="n">Elements</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">H</span><span class="o">-&gt;</span><span class="n">Size</span><span class="w"> </span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">temp</span><span class="p">;</span>
<span class="w">        </span><span class="n">temp</span><span class="o">=</span><span class="n">H</span><span class="o">-&gt;</span><span class="n">Elements</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
<span class="w">        </span><span class="n">H</span><span class="o">-&gt;</span><span class="n">Elements</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">=</span><span class="n">H</span><span class="o">-&gt;</span><span class="n">Elements</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="mi">2</span><span class="p">];</span>
<span class="w">        </span><span class="n">H</span><span class="o">-&gt;</span><span class="n">Elements</span><span class="p">[</span><span class="n">p</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">temp</span><span class="p">;</span>
<span class="w">        </span><span class="n">p</span><span class="w"> </span><span class="o">*=</span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span>
<span class="p">}</span>
</code></pre></div></p>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.8fd75fb4.min.js"></script>
      
    
  </body>
</html>