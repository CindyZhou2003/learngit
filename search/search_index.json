{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Cindy's site","text":""},{"location":"#about-this-site","title":"About this site","text":"<p>Some notes about course I've taken during my years in ZJU-SE. Still being constructed...</p>"},{"location":"#commands-about-how-to-build-the-site","title":"Commands about how to build the site","text":"<p>For full documentation visit mkdocs.org.</p> <ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> <li><code>mkdocs gh-deploy</code> - Push to the github.</li> </ul>"},{"location":"SE_courses/FDS/","title":"FDS","text":"<p>\u6570\u636e\u7ed3\u6784\u4e0e\u7b97\u6cd5\uff08\u5468\u6d4b1-\u7b97\u6cd5\u5206\u6790\uff09 - nonlinearthink - \u535a\u5ba2\u56ed</p>"},{"location":"SE_courses/FDS/#_1","title":"\u5f15\u8bba","text":"<p>ADT abstract data type \u62bd\u8c61\u6570\u636e\u7c7b\u578b $O(N)\u2264$  $\u03a9(N)\u2265$  $\u0398(N)=$  $o(N)\uff1c$</p>"},{"location":"SE_courses/FDS/#sort","title":"\u6392\u5e8f sort","text":"<p>stable \u7a33\u5b9a: A sorting algorithm is said to be stable if two items with equal keys _in the same order _in the sorted output as they appear in the input array. That is, the order of elements with identical keys is preserved.</p>"},{"location":"SE_courses/FDS/#quick-sort","title":"Quick Sort \u5feb\u901f\u6392\u5e8f","text":"<p>Quick Sort is a sorting algorithm that works using the divide-and-conquer approach. It chooses a pivot places it in its correct position in the sorted array and partitions the smaller elements to its left and the greater ones to its right. This process is continued for the left and right parts and the array is sorted.\u4e24\u8fb9\u5206\u7ec4\u6392\u5e8f\u65f6\u95f4\u590d\u6742\u5ea6\uff1a$O(N logN)$\u5e73\u5747\u6bcf\u4e00\u8f6e\u6392\u5e8f run \u90fd\u6709\u4e00\u4e2a\u6570 pivot \u88ab\u653e\u5230\u6700\u7ec8\u6b63\u786e\u7684\u4f4d\u7f6e\u4e0aThe position of the pivot element is finalized after each partitioning.</p>"},{"location":"SE_courses/FDS/#heap-sort","title":"Heap Sort \u5806\u6392\u5e8f","text":"<p>Heap Sort - Data Structures and Algorithms Tutorials - GeeksforGeeksHeap sort is a comparison-based sorting technique based on Binary Heap data structure. It is similar to the selection sort where we first find the minimum element and place the minimum element at the beginning. Repeat the same process for the remaining elements.\u9996\u5148\u4f7f\u7528 heapify (percolate down) \u5c06\u6570\u7ec4\u8f6c\u6362\u4e3a\u5806\u6570\u636e\u7ed3\u6784\uff0c\u7136\u540e\u9010\u4e2a\u5220\u9664 Max-heap \u7684\u6839\u8282\u70b9\uff0c\u5c06\u5176\u66ff\u6362\u4e3a\u5806\u4e2d\u7684\u6700\u540e\u4e00\u4e2a\u8282\u70b9\uff0c\u7136\u540e\u5806\u5316\u5806\u7684\u6839\u3002\u91cd\u590d\u6b64\u8fc7\u7a0b\uff0c\u76f4\u5230\u5806\u7684\u5927\u5c0f\u5927\u4e8e 1\u3002</p> <ul> <li>\u4ece\u7ed9\u5b9a\u7684\u8f93\u5165\u6570\u7ec4\u6784\u5efa\u5806\u3002</li> <li>\u91cd\u590d\u4ee5\u4e0b\u6b65\u9aa4\uff0c\u76f4\u5230\u5806\u53ea\u5305\u542b\u4e00\u4e2a\u5143\u7d20\uff1a</li> <li>\u5c06\u5806\u7684\u6839\u5143\u7d20\uff08\u5373\u6700\u5927\u7684\u5143\u7d20\uff09\u4e0e\u5806\u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u4ea4\u6362\u3002</li> <li>\u5220\u9664\u5806\u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\uff08\u73b0\u5728\u4f4d\u4e8e\u6b63\u786e\u4f4d\u7f6e\uff09\u3002</li> <li>\u5806\u780c\u5806\u7684\u5176\u4f59\u5143\u7d20\u3002</li> <li>\u6392\u5e8f\u540e\u7684\u6570\u7ec4\u662f\u901a\u8fc7\u53cd\u8f6c\u8f93\u5165\u6570\u7ec4\u4e2d\u5143\u7d20\u7684\u987a\u5e8f\u6765\u83b7\u5f97\u7684\u3002</li> </ul> <p>\u6027\u8d28\uff1aunstable\u65f6\u95f4\u590d\u6742\u5ea6\uff1a$O(N)$?? <pre><code>#include &lt;stdio.h&gt;\n\n// Function to swap the position of two elements\nvoid swap(int* a, int* b)\n{\n\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\n// To heapify a subtree rooted with node i\n// which is an index in arr[].\n// n is size of heap\nvoid heapify(int arr[], int N, int i)\n{\n    // Find largest among root,\n    // left child and right child\n\n    // Initialize largest as root\n    int largest = i;\n\n    // left = 2*i + 1\n    int left = 2 * i + 1;\n\n    // right = 2*i + 2\n    int right = 2 * i + 2;\n\n    // If left child is larger than root\n    if (left &lt; N &amp;&amp; arr[left] &gt; arr[largest])\n\n        largest = left;\n\n    // If right child is larger than largest\n    // so far\n    if (right &lt; N &amp;&amp; arr[right] &gt; arr[largest])\n\n        largest = right;\n\n    // Swap and continue heapifying\n    // if root is not largest\n    // If largest is not root\n    if (largest != i) {\n\n        swap(&amp;arr[i], &amp;arr[largest]);\n\n        // Recursively heapify the affected\n        // sub-tree\n        heapify(arr, N, largest);\n    }\n}\n\n// Main function to do heap sort\nvoid heapSort(int arr[], int N)\n{\n\n    // Build max heap\n    for (int i = N / 2 - 1; i &gt;= 0; i--)\n\n        heapify(arr, N, i);\n\n    // Heap sort\n    for (int i = N - 1; i &gt;= 0; i--) {\n\n        swap(&amp;arr[0], &amp;arr[i]);\n\n        // Heapify root element\n        // to get highest element at\n        // root again\n        heapify(arr, i, 0);\n    }\n}\n\n// A utility function to print array of size n\nvoid printArray(int arr[], int N)\n{\n    for (int i = 0; i &lt; N; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n\n// Driver's code\nint main()\n{\n    int arr[] = { 12, 11, 13, 5, 6, 7 };\n    int N = sizeof(arr) / sizeof(arr[0]);\n\n    // Function call\n    heapSort(arr, N);\n    printf(\"Sorted array is\\n\");\n    printArray(arr, N);\n}\n</code></pre></p>"},{"location":"SE_courses/FDS/#insertion-sort","title":"Insertion Sort \u63d2\u5165\u6392\u5e8f","text":"<p>Insertion Sort - Data Structure and Algorithm Tutorials - GeeksforGeeksInsertion sort is a simple sorting algorithm that works similarly to the way you sort playing cards in your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part are picked and placed at the correct position in the sorted part.\u82e5\u8981\u6309\u5347\u5e8f\u5bf9\u5927\u5c0f\u4e3a N \u7684\u6570\u7ec4\u8fdb\u884c\u6392\u5e8f\uff0c\u8bf7\u904d\u5386\u8be5\u6570\u7ec4\u5e76\u5c06\u5f53\u524d\u5143\u7d20\uff08\u952e\uff09\u4e0e\u5176\u524d\u4e00\u4e2a\u5143\u7d20\u8fdb\u884c\u6bd4\u8f83\uff0c\u5982\u679c\u5173\u952e\u5143\u7d20\u5c0f\u4e8e\u5176\u524d\u4e00\u4e2a\u5143\u7d20\uff0c\u8bf7\u5c06\u5176\u4e0e\u4e4b\u524d\u7684\u5143\u7d20\u8fdb\u884c\u6bd4\u8f83\u3002\u5c06\u8f83\u5927\u7684\u5143\u7d20\u5411\u4e0a\u79fb\u52a8\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u4ee5\u4fbf\u4e3a\u4ea4\u6362\u7684\u5143\u7d20\u817e\u51fa\u7a7a\u95f4\u3002\u65f6\u95f4\u590d\u6742\u5ea6\uff1a <pre><code>// C++ program for insertion sort\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// Function to sort an array using insertion sort\nvoid insertionSort(int arr[], int n)\n{\n    int i, key, j;\n    for (i = 1; i &lt; n; i++) {\n        key = arr[i];\n\n        // Move elements of arr[0..i-1],\n        // that are greater than key, \n        // to one position ahead of their\n        // current position\n        for ( j=i; j&gt;0 &amp;&amp; arr[j-1] &gt; key; j--){\n            arr[j] = arr[j-1];\n        }\n        arr[j] = key;\n    }\n}\n// A utility function to print an array of size n\nvoid printArray(int arr[], int n)\n{\n    int i;\n    for (i = 0; i &lt; n; i++)\n        cout &lt;&lt; arr[i] &lt;&lt; \" \";\n    cout &lt;&lt; endl;\n}\n\n// Driver code\nint main()\n{\n    int arr[] = { 12, 11, 13, 5, 6 };\n    int N = sizeof(arr) / sizeof(arr[0]);\n\n    insertionSort(arr, N);\n    printArray(arr, N);\n\n    return 0;\n}\n// This is code is contributed by rathbhupendra\n</code></pre></p>"},{"location":"SE_courses/FDS/#shell-sort","title":"Shell Sort \u5e0c\u5c14\u6392\u5e8f","text":"<p>Shell sort is mainly a variation of Insertion Sort. In insertion sort, we move elements only one position ahead. When an element has to be moved far ahead, many movements are involved. The idea of ShellSort is to allow the exchange of far items. In Shell sort, we make the array h-sorted for a large value of h. We keep reducing the value of h until it becomes 1.  An array is said to be h-sorted if all sublists of every h\u2019th element are sorted.\u5206\u7ec4 h-\u63d2\u5165\u6392\u5e8f\u6027\u8d28\uff1a unstable\u65f6\u95f4\u590d\u6742\u5ea6\uff1aAlgorithm:Step 1 \u2212 StartStep 2 \u2212 Initialize the value of gap size. Example: h.Step 3 \u2212 Divide the list into smaller sub-part. Each must have equal intervals to h.Step 4 \u2212 Sort these sub-lists using insertion sort.Step 5 \u2013 Repeat this step 2 until the list is sorted.Step 6 \u2013 Print a sorted list.Step 7 \u2013 Stop.</p> <p><pre><code>void Shellsort( ElementType A[ ], int N ) \n{ \n      int  i, j, Increment; \n      ElementType  Tmp; \n      for ( Increment = N / 2; Increment &gt; 0; Increment /= 2 )  \n    /*h sequence */\n    for ( i = Increment; i &lt; N; i++ ) { /* insertion sort */\n          Tmp = A[ i ]; \n          for ( j = i; j &gt;= Increment; j - = Increment ) \n        if( Tmp &lt; A[ j - Increment ] ) \n              A[ j ] = A[ j - Increment ]; \n        else \n              break; \n        A[ j ] = Tmp; \n    } /* end for-I and for-Increment loops */\n}\n</code></pre> Hibbard \u589e\u91cf\u5e8f\u5217$H_k=2^k-1$, \u4e14\u5176\u6700\u574f\u60c5\u5f62\u4e0b\u8fd0\u884c\u65f6\u95f4\u4e3a $O(N^{3/2})$</p>"},{"location":"SE_courses/FDS/#selection-sort","title":"Selection Sort \u9009\u62e9\u6392\u5e8f","text":""},{"location":"SE_courses/FDS/#merge-sort","title":"Merge Sort \u5f52\u5e76\u6392\u5e8f","text":"<p>\u6027\u8d28\uff1a stable\u65f6\u95f4\u590d\u6742\u5ea6\uff1a$O(N logN)$ <pre><code>// C program for Merge Sort\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n// Merges two subarrays of arr[].\n// First subarray is arr[l..m]\n// Second subarray is arr[m+1..r]\nvoid merge(int arr[], int l, int m, int r)\n{\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n\n    // Create temp arrays\n    int L[n1], R[n2];\n\n    // Copy data to temp arrays L[] and R[]\n    for (i = 0; i &lt; n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j &lt; n2; j++)\n        R[j] = arr[m + 1 + j];\n\n    // Merge the temp arrays back into arr[l..r\n    i = 0;\n    j = 0;\n    k = l;\n    while (i &lt; n1 &amp;&amp; j &lt; n2) {\n        if (L[i] &lt;= R[j]) {\n            arr[k] = L[i];\n            i++;\n        }\n        else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    // Copy the remaining elements of L[],\n    // if there are any\n    while (i &lt; n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    // Copy the remaining elements of R[],\n    // if there are any\n    while (j &lt; n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\n// l is for left index and r is right index of the\n// sub-array of arr to be sorted\nvoid mergeSort(int arr[], int l, int r)\n{\n    if (l &lt; r) {\n        int m = l + (r - l) / 2;\n\n        // Sort first and second halves\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n\n        merge(arr, l, m, r);\n    }\n}\n\n// Function to print an array\nvoid printArray(int A[], int size)\n{\n    int i;\n    for (i = 0; i &lt; size; i++)\n        printf(\"%d \", A[i]);\n    printf(\"\\n\");\n}\n\n// Driver code\nint main()\n{\n    int arr[] = { 12, 11, 13, 5, 6, 7 };\n    int arr_size = sizeof(arr) / sizeof(arr[0]);\n\n    printf(\"Given array is \\n\");\n    printArray(arr, arr_size);\n\n    mergeSort(arr, 0, arr_size - 1);\n\n    printf(\"\\nSorted array is \\n\");\n    printArray(arr, arr_size);\n    return 0;\n}\n</code></pre></p>"},{"location":"SE_courses/FDS/#bucket-sort","title":"Bucket Sort \u6876\u6392\u5e8f","text":""},{"location":"SE_courses/FDS/#_2","title":"\u95f4\u63a5/\u8868\u6392\u5e8f","text":"<p>\u6392\u5e8f\u7684\u5143\u7d20\u662f\u7ed3\u6784\u5927\uff0c\u79fb\u52a8\u6307\u9488\u6570\u7ec4\u8fdb\u884c\u6392\u5e8fN \u4e2a\u6570\u5b57\u7684\u6392\u5217\u4e00\u5b9a\u662f\u7531\u82e5\u5e72\u4e2a\u72ec\u7acb\u7684\u73af\u7ec4\u6210\u7684</p> <ul> <li>\u6bcf\u8bbf\u95ee\u4e00\u4e2a\u73af\uff0c\u5f53<code>table[i]==i</code>\u65f6\u73af\u7ed3\u675f</li> </ul> <p>\u65f6\u95f4\u590d\u6742\u5ea6\uff1a\uff08\u6700\u574f\uff09\u5411\u4e0b\u53d6\u6574 N/2 \u4e2a\u73af\uff0c\u6bcf\u4e2a\u73af\u5305\u62ec\u4e24\u4e2a\u5143\u7d20\uff1b \u603b$O(M*n)$\uff0cM \u662f\u6bcf\u4e2a\u5143\u7d20 A \u590d\u5236\u7684\u65f6\u95f4</p>"},{"location":"SE_courses/FDS/#q","title":"Q","text":"<ol> <li>If there are less than 20 inversions in an integer array, then Insertion Sort will be the best method among Quick Sort, Heap Sort and Insertion Sort. T</li> <li>For the quicksort implementation with the left pointer stops at an element with the same key as the pivot during the partitioning, but the right pointer does not stop in a similar case, what is the running time when all keys are equal?</li> <li>$O(logN)$</li> <li>$O(N)$</li> <li>$O(NlogN)$</li> <li>$O(N^2)$</li> </ol> <p>The running time is $O(n^2)$ in the worst case [6]. This is because in such a situation, the partitioning doesn't effectively divide the array into smaller subproblems, leading to a degenerate case where the algorithm essentially performs a linear scan. Quicksort's typical efficiency relies on dividing the problem into subproblems, and when this doesn't occur due to equal keys, the algorithm's performance degrades.\uff08answer from AI\uff09</p> <ol> <li>To sort { 49, 38, 65, 97, 76, 13, 27, 50 } in increasing order, which of the following is the result after the 1st run of Shell sort with the initial increment 4? </li> <li>13,27,38,49,50,65,76,97</li> <li>49,13,27,50,76,38,65,97</li> <li>49,76,65,13,27,50,97,38</li> <li>97,76,65,50,49,38,27,13</li> </ol> <p>First Pass (Increment 4):</p> <ul> <li>Compare elements at positions 1 and 5 (49 and 76), no swap needed.</li> <li>Compare elements at positions 2 and 6 (38 and 13), swap.</li> <li>Compare elements at positions 3 and 7 (65 and 27), swap.</li> <li>Compare elements at positions 4 and 8 (97 and 50), swap.</li> <li>if not present due to length, no swap needed.</li> <li> <p>Among the following sorting methods, which ones will be slowed down if we store the elements in a linked structure instead of a sequential structure? </p> </li> <li> <p>Insertion sort; 2. Select ion Sort; 3. Bubble sort; 4. Shell sort; 5. Heap sort</p> </li> <li> <p>1 and 2 only</p> </li> <li>2 and 3 only</li> <li>3 and 4 only</li> <li>4 and 5 only</li> </ul> <p>Heap sort\u662f\u5728\u6570\u7ec4\u4e2d, heap\u672c\u8eab\u5728\u6570\u7ec4\u4e2d, shell sort\u4e5f\u662f\u5728\u6570\u7ec4\u4e2d\uff0c \u94fe\u8868\u67e5\u8be2\u8f83\u6162</p> <ol> <li>To sort N elements by heap sort, the extra space complexity is: $O(1)$</li> <li>During the sorting, processing every element which is not yet at its final position is called a \"run\". To sort a list of integers using quick sort, it may reduce the total number of recursions by processing the small partion first in each run. **F **</li> </ol> <p>\u5e0c\u671b\u5e73\u5747\u5206\uff0c\u5904\u7406\u4e24\u4e2a\u90fd\u4e00\u6837\u7684</p> <ol> <li></li> </ol>"},{"location":"SE_courses/FDS/#hashing","title":"\u6563\u5217 hashing","text":"<p>\u51b2\u7a81 collision\uff1aTwo elements with different keys share the same hash value\u88c5\u586b\u56e0\u5b50 load factor: $\u03bb=n/tablesize$\u6563\u5217\u5e73\u5747\u67e5\u627e\u671f\u671b\u662f$O(1)$\uff0c\u51e0\u4e4e\u4e0e\u5173\u952e\u5b57\u7a7a\u95f4 n \u65e0\u5173</p> <ul> <li>\u4ee5\u8f83\u5c0f\u7684\u88c5\u586b\u56e0\u5b50\u4e3a\u524d\u63d0\uff0c\u4ee5\u7a7a\u95f4\u6362\u65f6\u95f4</li> <li>\u4e0d\u4fbf\u4e8e\u987a\u5e8f\u67e5\u627e\u5173\u952e\u5b57\u3001\u8303\u56f4\u67e5\u627e\u3001\u6700\u5927\u6700\u5c0f\u503c\u67e5\u627e\u7b49</li> </ul>"},{"location":"SE_courses/FDS/#_3","title":"\u5206\u79bb\u94fe\u63a5\u6cd5","text":"<p>\u628a\u6240\u6709\u6709\u51b2\u7a81\u7684 key \u7528\u94fe\u8868\u4e32\u8054\u5728\u4e00\u8d77\u88c5\u586b\u56e0\u5b50\u53ef\u80fd\u8d85\u8fc7 1\uff0c\u6210\u529f\u67e5\u627e\u671f\u671b\u7565\u5927\u4e8e\u4e0d\u6210\u529f\u94fe\u8868\u50a8\u5b58\u6548\u7387\u548c\u67e5\u627e\u6548\u7387\u6bd4\u8f83\u4f4e\u5173\u952e\u5b57\u5220\u9664\u4e0d\u9700\u8981\u201c\u61d2\u60f0\u5220\u9664\u201d\u6cd5\u592a\u5c0f\u7684\u88c5\u586b\u56e0\u5b50\u53ef\u80fd\u6d6a\u8d39\u7a7a\u95f4\uff0c\u592a\u5927\u5c06\u4ed8\u51fa\u65f6\u95f4\u4ee3\u4ef7</p>"},{"location":"SE_courses/FDS/#_4","title":"\u5f00\u653e\u5b9a\u5740\u6cd5","text":"<p>\u5982\u679c\u53d1\u751f\u7b2c i \u6b21\u51b2\u7a81\uff0c\u63a2\u6d4b\u7684\u4e0b\u4e00\u4e2a\u5730\u5740+di\u88c5\u586b\u56e0\u5b50\u8d8a\u5927\uff0c\uff08\u4e0d\uff09\u6210\u529f\u67e5\u627e\u671f\u671b\u6b21\u6570\u8d8a\u5927\uff08\u6307\u6570\u7ea7\u589e\u957f\uff0c\u4e0d\u6210\u529f&gt;\u6210\u529f\uff09\uff1b\u88c5\u586b\u56e0\u5b50\u8f83\u5c0f\u65f6\uff0c\u5404\u79cd\u671f\u671b\u63a2\u6d4b\u6b21\u6570\u90fd\u4e0d\u5927\u4e14\u6bd4\u8f83\u63a5\u8fd1\u3002\u6563\u5217\u8868\u662f\u4e2a\u6570\u7ec4\uff0c\u50a8\u5b58\u6548\u7387\u9ad8\uff0c\u968f\u673a\u67e5\u627e\uff0c\u6709\u805a\u96c6\u73b0\u8c61</p>"},{"location":"SE_courses/FDS/#linear-probing","title":"\u7ebf\u6027\u63a2\u6d4b\u6cd5 Linear probing","text":"<p>$di=i$\u5e73\u5747\u67e5\u627e\u957f\u5ea6\uff08\u6b21\u6570\uff09\u4e00\u822c\u5931\u8d25&gt;\u6210\u529f\u6210\u529f\u67e5\u627e\u957f\u5ea6 ASLs\uff1a\u6563\u5217\u4e2d\u6bcf\u4e2a\u5143\u7d20\u8981\u627e xi \u6b21\uff08xi=\u51b2\u7a81\u6b21\u6570+1\uff09\uff0c\u76f8\u52a0\u53d6\u5e73\u5747\uff08\u2797\u5b9e\u9645\u54c8\u5e0c\u8868\u5143\u7d20\u4e2a\u6570\uff09\u5931\u8d25\u67e5\u627e\u957f\u5ea6 ASLu\uff1a\u627e\u4e0d\u5728\u6563\u5217\u4e2d\u7684\u5143\u7d20\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u54c8\u5e0c\u503c h(x)\uff0c \u7167\u6837 mod + \u540e\u79fb\u627e\uff0c\u82e5\u662f\u9047\u5230\u7a7a\u683c\u5219\u8bc1\u660e\u4e0d\u5728\u6563\u5217\u4e2d\uff0c\u6b64\u65f6\u7684\u67e5\u627e\u6b21\u6570 xi \u76f8\u52a0\u53d6\u5e73\u5747</p>"},{"location":"SE_courses/FDS/#quadratic-probing","title":"\u5e73\u65b9\u63a2\u6d4b\u6cd5 Quadratic probing","text":"<p>\u589e\u91cf\u5e8f\u5217\uff1a1\uff0c-1\uff0c$2^2$\uff0c$-2^2$\uff0c$3^2$\uff0c$-3^2$, \u2026\u2026 ,$q^2$,$-q^2$\u4e14 $q\u2264\u230atablesize/2\u230b$\u53ef\u80fd\u51fa\u73b0\u8868\u6709\u4f4d\u7f6e\u4f46\u627e\u4e0d\u5230\u7684\u60c5\u51b5\uff08$i^2$\u4e5f\u4e00\u6837 )\u4f7f\u7528\u5e73\u65b9\u63a2\u6d4b\u6cd5\uff1a\u5f53\u8868\u7684\u5927\u5c0f\u662f\u7d20\u6570\u4e14\u8868\u6709\u4e00\u534a\u662f\u7a7a\u7684\u7684\u65f6\u5019\uff0c\u603b\u80fd\u63d2\u5165\u4e00\u4e2a\u65b0\u7684\u5143\u7d20\u5982\u679c\u8868\u7684\u5927\u5c0f\u662f\u5f62\u5982 4k+3 \u7684\u7d20\u6570\uff0c\u4f7f\u7528 $F(i)=+-i^2$\uff0c\u90a3\u4e48\u6574\u4e2a\u8868\u90fd\u80fd\u88ab\u63a2\u6d4b\u5230</p>"},{"location":"SE_courses/FDS/#q_1","title":"Q","text":"<ol> <li>Which of the following statements about HASH is true? </li> <li>the expected number of probes for insertions is greater than that for successful searches in linear probing method</li> <li>insertions are generally quicker than deletions in separate chaining method</li> <li>if the table size is prime and the table is at least half empty, a new element can always be inserted with quadratic probing</li> <li>all of the above</li> <li>The average search time of searching a hash table with N elements is:</li> <li>$O(1)$</li> <li>$O(logN)$</li> <li>$O(N)$</li> <li>cannot be determined</li> </ol>"},{"location":"SE_courses/FDS/#list","title":"\u8868 List","text":""},{"location":"SE_courses/FDS/#q_2","title":"Q","text":"<p>For a sequentially stored linear list of length N, the time complexities for query and insertion are O(1) and O(N), respectively. T</p>"},{"location":"SE_courses/FDS/#stack","title":"\u6808 stack","text":"<p>\u6808\uff08Stack\uff09\uff1a\u662f\u53ea\u5141\u8bb8\u5728\u4e00\u7aef\u8fdb\u884c\u63d2\u5165\u6216\u5220\u9664\u7684\u7ebf\u6027\u8868\u3002\u9996\u5148\u6808\u662f\u4e00\u79cd\u7ebf\u6027\u8868\uff0c\u4f46\u9650\u5b9a\u8fd9\u79cd\u7ebf\u6027\u8868\u53ea\u80fd\u5728\u67d0\u4e00\u7aef\u8fdb\u884c\u63d2\u5165\u548c\u5220\u9664\u64cd\u4f5c\u3002Last-in-First-out <pre><code>void Push(Elementstype X, Stack S){\n    PtrtoNode Tmp;\n    //\u7565\u53bb\u5224\u65ad\u662f\u4e0d\u662fNULL\n    Tmp-&gt;Element=X;\n    Tmp-&gt;Next=S-&gt;Next;//\u6362\u8868\u5934\n    S-&gt;Next=Tmp;\n}\nvoid Pop(Stack S){\n    PtrtoNode first;\n    //\u7565\u53bb\u5224\u65ad\u662f\u4e0d\u662f\u7a7a\n    first=S-&gt;Next;\n    S-&gt;Next=S-&gt;Next-&gt;Next;//\u6362\u8868\u5934\n    free(first);\n}\n</code></pre> <pre><code>void Push(Stack S){\n    //\u7565\u53bb\u5224\u65ad\u662f\u4e0d\u662f\u6ee1\u4e86\n    S-&gt;Array[++S-&gt;TopOfStack]=X;\n}\nvoid Pop(Stack S){\n    //\u7565\u53bb\u5224\u65ad\u662f\u4e0d\u662f\u7a7a\n    S-&gt;TopOfStack--;\n}\n</code></pre></p>"},{"location":"SE_courses/FDS/#q_3","title":"Q","text":"<ul> <li>Stacks and queues are lists with insertion/deletion constraints.</li> </ul>"},{"location":"SE_courses/FDS/#queue","title":"\u961f\u5217 queue","text":"<p>First-in-first-outcircular array\u68c0\u6d4b\u961f\u5217\u662f\u4e0d\u662f\u7a7a\u662f\u5f88\u91cd\u8981\u7684</p>"},{"location":"SE_courses/FDS/#q_4","title":"Q","text":"<p>Suppose that an array of size m is used to store a circular queue. If the front position is front and the current size is size, then the rear element must be at (front+size-1)%m.</p>"},{"location":"SE_courses/FDS/#tree","title":"\u6811 Tree","text":"<p>\u6df1\u5ea6 \u6839 \u5230 \u8282\u70b9 ni \uff08\u6839\u7684\u6df1\u5ea6\u4e3a 0\uff0c\u6811\u7684\u6df1\u5ea6\u662f\u5b83\u6700\u6df1\u6811\u53f6\u7684\u6df1\u5ea6\uff09\u9ad8\u5ea6 \u8282\u70b9 ni \u5230\u53f6\u5b50 \uff08\u6811\u7684\u9ad8\u5ea6\u662f\u6839\u7684\u9ad8\u5ea6\uff09\u8def\u5f84 \u8282\u70b9\u7684\u4e00\u4e2a\u987a\u5e8f\uff0c\u4e00\u68f5\u6811\u4e2d\u4ece\u6839\u5230\u6bcf\u4e2a\u8282\u70b9\u6070\u597d\u5b58\u5728\u4e00\u6761\u8def\u5f84</p>"},{"location":"SE_courses/FDS/#binary-tree","title":"Binary Tree","text":"<p>\u5ea6\u6570\u4e3a 0 \u7684\u8282\u70b9 = \u5ea6\u6570\u4e3a 2 \u7684\u8282\u70b9+1</p>"},{"location":"SE_courses/FDS/#complete-binary-tree","title":"\u5b8c\u5168\u4e8c\u53c9\u6811 complete binary tree","text":"<p>The parent of a node at index _i _ is located at index $\u230ai/2\u230b$</p>"},{"location":"SE_courses/FDS/#insert","title":"insert \u63d2\u5165","text":"<p>\u5982\u679c\u961f\u5217\u91cc\u6ca1\u6709 X\uff0c<code>Insert(Elemnettype X, SearchTree T)</code>\u5c06 X \u63d2\u5165\u5230\u904d\u5386\u8def\u5f84\u7684\u6700\u540e\u4e00\u70b9\u4e0a</p>"},{"location":"SE_courses/FDS/#binary-search-treebst","title":"\u4e8c\u53c9\u67e5\u627e\u6811 Binary Search Tree\uff08BST\uff09","text":"<p>\u5de6\u8fb9\u90fd\u6bd4\u6839\u5c0f\uff0c\u53f3\u8fb9\u90fd\u6bd4\u6839\u5927\u6811\u7684\u5e73\u5747\u6df1\u5ea6 $O(Nlog N)$</p>"},{"location":"SE_courses/FDS/#delete","title":"Delete","text":"<p>\u5de6\u5b50\u6811\u6700\u5927\u6216\u8005\u53f3\u5b50\u6811\u6700\u5c0f\u7684\u6570\u6765\u4ee3\u66ff\u88ab\u5220\u6389\u7684\u8282\u70b9\uff08\u4e0d\u662f\u53f6\u5b50</p>"},{"location":"SE_courses/FDS/#ternary-tree","title":"ternary tree \u4e09\u53c9\u6811","text":"<p>The number of leaf nodes in a ternary tree (\u4e09\u53c9\u6811) is only related to the number of degree 2 nodes and that of degree 3 nodes, namely, it has nothing to do with the number of degree 1 nodes.</p>"},{"location":"SE_courses/FDS/#perfect-binary-tree","title":"Perfect binary tree \u7406\u60f3\u4e8c\u53c9\u6811","text":"<p>\u6ee1\u4e8c\u53c9\u6811\uff0c\u662f\u4e00\u79cd\u7279\u6b8a\u7c7b\u578b\u7684\u4e8c\u53c9\u6811\u3002\u5728\u7406\u60f3\u4e8c\u53c9\u6811\u4e2d\uff0c\u9664\u4e86\u53f6\u5b50\u8282\u70b9\u4e4b\u5916\uff0c\u6bcf\u4e2a\u8282\u70b9\u90fd\u6709\u4e24\u4e2a\u5b50\u8282\u70b9\uff0c\u4e14\u6240\u6709\u53f6\u5b50\u8282\u70b9\u90fd\u4f4d\u4e8e\u540c\u4e00\u5c42\u6b21\u4e0a\u3002\u8fd9\u4f7f\u5f97\u7406\u60f3\u4e8c\u53c9\u6811\u5177\u6709\u826f\u597d\u7684\u5e73\u8861\u6027\u3002</p>"},{"location":"SE_courses/FDS/#q_5","title":"Q","text":"<ol> <li>In a complete binary tree with 1102 nodes, there must be __ leaf nodes. </li> <li>79</li> <li>551</li> <li>1063</li> <li>cannot be determined</li> <li>n \u4e3a\u5076\u6570\uff0cleaf nodes \u7684\u6570\u91cf=$n/2$; n \u4e3a\u5947\u6570\uff0cleaf nodes \u7684\u6570\u91cf=$(n+1)/2$</li> <li>In-order traversal of a binary tree can be done iteratively. Given the stack operation sequence as the following:<code>push(1), push(2), push(3), pop(), push(4), pop(), pop(), push(5), pop(), pop(), push(6), pop()</code></li> </ol> <p>Which one of the following statements is TRUE? </p> <ol> <li>6 is the root</li> <li>2 is the parent of 4</li> <li>2 and 6 are siblings</li> <li>None of the above</li> <li>\u5165\u6808\u987a\u5e8f\u5373\u4e3a\u5148\u5e8f\u904d\u5386\u7684\u987a\u5e8f\uff0c\u51fa\u6808\u987a\u5e8f\u5373\u4e3a\u4e2d\u5e8f\u904d\u5386\u7684\u987a\u5e8f</li> <li>\u5165\u6808 123456 \u51fa\u6808 342516</li> </ol> <p>re <pre><code>Tree BuildTree( int in[], int pre[], int N )\n{ //in[] stores the inorder traversal sequence\n//and pre[] stores the preorder traversal sequence\n//N is the number of nodes in the tree\n    Tree T;\n    int i;\n    if (!N) {\n    return NULL;\n    }\n    T = (Tree)malloc(sizeof(struct Node));\n    T-&gt;Data = pre[0];\n    for (i=0; i&lt;N; i++)\n        if (in[i]==T-&gt;Data) break;\n    T-&gt;Left = BuildTree( in, pre+1, i);\n    T-&gt;Right = BuildTree( in+i+1, pre+i+1, N-i-1);\n    return T;\n}\n</code></pre></p> <pre><code>Tree BuildTree( int in[], int post[], int N )\n{ \n    Tree T;\n    int i;\n    if (!N) {\n    return NULL;\n    }\n    T = (Tree)malloc(sizeof(struct Node));\n    T-&gt;Data = post[N-1];\n    for (i=0; i&lt;N; i++)\n        if (in[i]==T-&gt;Data) break;\n    T-&gt;Left = BuildTree( in, post, i);\n    T-&gt;Right = BuildTree( in+i+1, post+i+1, N-i);\n    return T;\n}\n</code></pre>"},{"location":"SE_courses/FDS/#heap","title":"\u5806 Heap \u4f18\u5148\u961f\u5217","text":"<p>\u5806\u5e8f\u6027 heap order</p> <ul> <li>the nodes along the path from the root to any node are in sorted order</li> </ul> <p>\u4e8c\u53c9\u5806 binary heap \u662f\u5b8c\u5168\u586b\u6ee1\u7684\u4e8c\u53c9\u6811 complete binary tree\u8282\u70b9\u6570 $2^h$~$2^h-1$\u9ad8\u5ea6 h $\u230alogN\u230b$\u7236\u4eb2\u5728$\u230ai/2\u230b$\u4f4d\u7f6e\u4e0a</p>"},{"location":"SE_courses/FDS/#insert_1","title":"Insert","text":""},{"location":"SE_courses/FDS/#percolate-up","title":"\u4e0a\u6ee4 percolate up","text":"<p>\u5728\u4e0b\u4e00\u4e2a\u7a7a\u7684\u4f4d\u7f6e\u5efa\u4e00\u4e2a\u7a7a\u7a74\uff0c\u5411\u6839\u7684\u65b9\u5411\u4e0a\u8d70\uff0c\u76f4\u5230\u80fd\u653e\u5165 X</p>"},{"location":"SE_courses/FDS/#deletemin","title":"DeleteMin","text":""},{"location":"SE_courses/FDS/#percolate-down","title":"\u4e0b\u6ee4 percolate down","text":"<p>\u5c06\u5220\u9664\u5143\u7d20\u4e2d\u513f\u5b50\u7684\u8f83\u5c0f\u503c\u653e\u5165\u7a7a\u7a74\uff0c\u7a7a\u7a74\u4e0b\u79fb\u4e00\u5c42\uff0c\u91cd\u590d\u64cd\u4f5c\uff0c\u76f4\u5230\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u653e\u5230\u6b63\u786e\u7684\u4f4d\u7f6e\u4e0a\uff08\u8981\u6ee1\u8db3\u5b8c\u5168\u4e8c\u53c9\u6811\uff09</p>"},{"location":"SE_courses/FDS/#build","title":"Build","text":"<p>\u7528 Insert O(N)</p>"},{"location":"SE_courses/FDS/#increasekey","title":"IncreaseKey","text":"<pre><code>void IncreaseKey( int P, int D, PriorityQueue H )\n{\n   int i, key;\n   key = H-&gt;Elements[P] + D;\n   for ( i = P; H-&gt;Elements[i/2] &lt; key; i/=2 )     \n        H-&gt;element[i]=H-&gt;Element[i/2];\n   H-&gt;Elements[i] = key;\n}\n</code></pre>"},{"location":"SE_courses/FDS/#decreasekey","title":"DecreaseKey","text":"<pre><code>void DecreaseKey( int P, int D, PriorityQueue H )\n{\n    int i, key;\n    key = H-&gt;Elements[P] - D;\n    for ( i = P; H-&gt;Elements[i/2] &gt; key; i/=2 )\n        H-&gt;Elements[i] = H-&gt;Elements[i/2];\n    H-&gt;Elements[i] = key;\n}\n</code></pre>"},{"location":"SE_courses/FDS/#relation","title":"\u5173\u7cfb Relation","text":""},{"location":"SE_courses/FDS/#equivalence-relation","title":"\u7b49\u4ef7\u5173\u7cfb equivalence relation","text":"<ul> <li>\u81ea\u53cd\u6027 reflexive</li> <li>\u5bf9\u79f0\u6027 symmetric</li> <li>\u4f20\u9012\u6027 transitive</li> </ul> <p>eg. \u76f8\u4f3c\u3001\u6a21\u8fd0\u7b97\u3001\u56fe\u50cf\u8fde\u901a\u6027</p>"},{"location":"SE_courses/FDS/#equivalence-class","title":"\u7b49\u4ef7\u7c7b equivalence class","text":"<p>\u5bf9\u4e8e \u96c6\u5408 S \u6709 n \u4e2a\u5143\u7d20\uff0c\u7b49\u4ef7\u7c7b equivalence class \u6570\u91cf x\uff0c \u6709 1\u2264x\u2264n \u4e2a\u7b49\u4ef7\u7c7b\u5f62\u6210\u5bf9 S \u7684\u4e00\u4e2a\u5212\u5206\uff1aS \u7684\u6bcf\u4e2a\u6210\u5458\u6070\u597d\u51fa\u73b0\u5728\u4e00\u4e2a\u7b49\u4ef7\u7c7b\u4e2d</p> <p>\u4e0d\u76f8\u4ea4 disjoint</p>"},{"location":"SE_courses/FDS/#unionfind","title":"Union/Find \u7b97\u6cd5\uff08\u5e76\u67e5\u7b97\u6cd5\uff09","text":"<p>array[] \u4e2d\u6bcf\u4e2a\u5143\u7d20\u5b58\u7684\u662f\u5b83\u7684\u6839\u8282\u70b9\u7684\u503cIntroduction to Disjoint Set (Union-Find Algorithm) - GeeksforGeeks</p>"},{"location":"SE_courses/FDS/#find","title":"Find","text":"<p>Find(i) O(X)\u4e0e X \u8282\u70b9\u7684\u6df1\u5ea6\u6210\u6b63\u6bd4 \u8fd4\u56de\u7b49\u4ef7\u7c7b\u540d\u5b57\uff08\u5f53\u4e14\u4ec5\u5f53\u4e24\u4e2a\u5143\u7d20\u5c5e\u4e8e\u76f8\u540c\u96c6\u5408\u65f6\uff0cFind \u8fd4\u56de\u76f8\u540c\u540d\u5b57 <pre><code>// Finds the representative of the set\n// that i is an element of\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint find(int i)\n{\n    // If i is the parent of itself\n    if (parent[i] == i) {\n        // Then i is the representative of\n        // this set\n        return i;\n    }\n    else {\n        // Else if i is not the parent of\n        // itself, then i is not the\n        // representative of his set. So we\n        // recursively call Find on its parent\n        return find(parent[i]);\n    }\n}\n// The code is contributed by Nidhi goel\n</code></pre> <pre><code>Find ( ElementType X, DisjSet S )\n{   \n    ElementType root, trail, lead;\n\n    for ( root = X; S[root] &gt; 0; root=S[root]) ;  \n    for ( trail = X; trail != root; trail = lead ) {\n        lead = S[trail] ;   \n        S[trail]=root;   \n    } \n    return root;\n}\n</code></pre></p>"},{"location":"SE_courses/FDS/#union","title":"Union","text":"<p>Union(a,b) \u0398(N) \u5c06 a \u548c b \u4e24\u4e2a\u7b49\u4ef7\u7c7b\u5408\u5e76\u6210\u4e00\u4e2a\u65b0\u7684\u7b49\u4ef7\u7c7bUnion(a,b)\u540e\u65b0\u7684\u6839\u662f a <pre><code>// Unites the set that includes i\n// and the set that includes j\n\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nvoid union(int i, int j) {\n    // Find the representatives\n    // (or the root nodes) for the set\n    // that includes i\n    int irep = this.Find(i),\n    // And do the same for the set\n    // that includes j\n    int jrep = this.Find(j);\n    // Make the parent of i\u2019s representative\n    // be j\u2019s representative effectively\n    // moving all of i\u2019s set into j\u2019s set)\n    this.Parent[irep] = jrep;\n}\n</code></pre></p>"},{"location":"SE_courses/FDS/#union-by-size","title":"union-by-size \u6309\u5927\u5c0f\u6c42\u5e76","text":"<p>\u5c0f\u7684\u5e76\u5230\u5927\u7684\u4e0a\u4efb\u4f55\u8282\u70b9\u7684\u6df1\u5ea6 depth \u4e0d\u4f1a\u8d85\u8fc7$log(N)$$height(T)\u2264\u230alog_2 N\u230b +1$</p>"},{"location":"SE_courses/FDS/#union-by-height","title":"union-by-height \u6309\u9ad8\u5ea6\u6c42\u5e76","text":"<p>\u4efb\u4f55\u8282\u70b9\u7684\u6df1\u5ea6 depth \u2264 \u4e0d\u4f1a\u8d85\u8fc7$log(N)$</p>"},{"location":"SE_courses/FDS/#path-compression","title":"\u8def\u5f84\u538b\u7f29 path compression","text":"<p>\u5728 Find \u64cd\u4f5c\u4e2d\u6267\u884c\uff0c \u4ece X \u5230\u6839\u7684\u8def\u5f84\u4e0a\u7684\u6bcf\u4e00\u4e2a\u8282\u70b9\u90fd\u4f7f\u5b83\u7684\u7236\u8282\u70b9\u53d8\u6210\u6839\uff0c\u5373 \u4f7f S[X] \u7684\u503c\u7b49\u4e8e Find \u8fd4\u56de\u7684\u503c\u8def\u5f84\u538b\u7f29\u4e0e\u6309\u5927\u5c0f\u6c42\u5e76\u5b8c\u5168\u517c\u5bb9 <pre><code>SetType Find ( ElementType X, DisjSet S )\n{   \n   ElementType root, trail, lead;\n\n   for ( root = X; S[root] &gt; 0; root=S[root]) ;  \n   for ( trail = X; trail != root; trail = lead ) {\n      lead = S[trail] ;   \n      S[trail]=root;   \n   } \n   return root;\n}\n</code></pre> <pre><code>//The function BuildMinHeap(H, K) is to arrange elements H[1] ... H[K] into a min-heap. \n//Please complete the following program.\n\nElementType FindKthLargest ( int A[], int N, int K )\n{   /* it is assumed that K&lt;=N */\n    ElementType *H;\n    int i, next, child;\n\n    H = (ElementType *)malloc((K+1)*sizeof(ElementType));\n    for ( i=1; i&lt;=K; i++ ) H[i] = A[i-1];\n    BuildMinHeap(H, K);\n\n    for ( next=K; next&lt;N; next++ ) {\n        H[0] = A[next];\n        if ( H[0] &gt; H[1] ) {\n            for ( i=1; i*2&lt;=K; i=child ) {\n                child = i*2;\n                if ( child!=K &amp;&amp; H[child+1]&lt;H[child] ) child++;\n                if ( H[0] &gt; H[child] )\n                    H[i] = H[child];\n                else break;\n            }\n            H[i] = H[0];\n        }\n    }\n    return H[1];\n}\n</code></pre></p>"},{"location":"SE_courses/FDS/#q_6","title":"Q","text":"<ol> <li>The array representation of a disjoint set is given by { 4, 6, 5, 2, -3, -4, 3 }. If the elements are numbered from 1 to 7, the resulting array after invoking <code>Union(Find(7),Find(1))</code> with union-by-size and path-compression is: </li> <li>{ 4, 6, 5, 2, 6, -7, 3 }</li> <li>{ 4, 6, 5, 2, -7, 5, 3 }</li> <li>{ 6, 6, 5, 6, -7, 5, 5 }</li> <li>{ 6, 6, 5, 6, 6, -7, 5 }</li> </ol>"},{"location":"SE_courses/FDS/#_5","title":"FDS","text":""},{"location":"SE_courses/FDS/#graph","title":"\u56fe Graph","text":""},{"location":"SE_courses/FDS/#introduction","title":"introduction","text":"<p>In a directed graph, the sum of the in-degrees and out-degrees of all the vertices is twice the total number of edges.\u6c42\u548c degree=2E\u6709\u6700\u591a\u7684\u8fb9\u7684\u6570\u91cf\u6709\u5411\u56fe\u662f n(n-1) ,\u65e0\u5411\u56fe\u662f n(n-1) /2*</p>"},{"location":"SE_courses/FDS/#connected","title":"connected","text":"<p>There are n vertices. The minimum number of edges in a connected graph is (n-1). The maximum for this question is (n-1) (n-2)/2 + 1. This is because (n-1) edges can be connected by maximum (n-1) (n-2)/2 edges, and 1 edge to connect to the lonely vertex.</p>"},{"location":"SE_courses/FDS/#articulation-pointcut-vertex","title":"\u5272\u70b9 articulation point/cut vertex","text":"<p>A vertex v is an articulation point (also called cut vertex) if removing v increases the number of connected components.</p>"},{"location":"SE_courses/FDS/#topological","title":"\u62d3\u6251\u6392\u5e8f topological","text":"<p>\u5bf9\u6709\u5411\u65e0\u5708\u56fe\u7684\u9876\u70b9\u7684\u4e00\u79cd\u6392\u5e8f</p>"},{"location":"SE_courses/FDS/#dijkstra-algorithm","title":"Dijkstra algorithm","text":"<p>\u627e\u5230\u4ece\u4e00\u4e2a\u7ed9\u5b9a\u70b9\u5230\u6240\u6709\u70b9\u4e4b\u95f4\u7684\u6700\u77ed\u8def\u5f84\u65f6\u95f4\u590d\u6742\u5ea6\uff1a$O(|E|+|V|^2)$</p>"},{"location":"SE_courses/FDS/#maximum-network-flow","title":"Maximum Network Flow  \u6700\u5927\u7f51\u7edc\u6d41","text":"<p>\u7ed9\u5b9a\u4e00\u4e2a\u8868\u793a\u6d41\u7f51\u7edc\u7684\u56fe\uff0c\u5176\u4e2d\u6bcf\u6761\u8fb9\u90fd\u6709\u5bb9\u91cf\u3002\u8fd8\u7ed9\u5b9a\u56fe\u4e2d\u7684\u4e24\u4e2a\u9876\u70b9\u6e90\u201cs\u201d\u548c\u6c47\u201ct\u201d\uff0c\u5728\u4ee5\u4e0b\u7ea6\u675f\u4e0b\u627e\u5230\u4ece s \u5230 t \u7684\u6700\u5927\u53ef\u80fd\u6d41\u91cf\uff1a  </p> <ol> <li>\u8fb9\u7f18\u4e0a\u7684\u6d41\u91cf\u4e0d\u4f1a\u8d85\u8fc7\u8fb9\u7f18\u7684\u7ed9\u5b9a\u5bb9\u91cf\u3002</li> <li>\u5bf9\u4e8e\u9664 s \u548c t \u4e4b\u5916\u7684\u6bcf\u4e2a\u9876\u70b9\uff0c\u4f20\u5165\u6d41\u7b49\u4e8e\u4f20\u51fa\u6d41\u3002</li> </ol>"},{"location":"SE_courses/FDS/#dinic","title":"Dinic","text":"<p>Dinic\u2019s algorithm for Maximum Flow - GeeksforGeeksDinic \u7684\u7b97\u6cd5\u4f7f\u7528\u4ee5\u4e0b\u6982\u5ff5\uff1a </p> <ol> <li>\u5c06\u6b8b\u5dee\u56fe G \u521d\u59cb\u5316\u4e3a\u7ed9\u5b9a\u56fe\u3002</li> <li>\u5bf9 G \u8fdb\u884c BFS \u6765\u6784\u9020\u4e00\u4e2a\u7ea7\u522b\u56fe\uff08\u6216\u5c06\u7ea7\u522b\u5206\u914d\u7ed9\u9876\u70b9\uff09\uff0c\u5e76\u68c0\u67e5\u662f\u5426\u53ef\u4ee5\u6709\u66f4\u591a\u6d41\u3002</li> <li>\u5982\u679c\u65e0\u6cd5\u83b7\u5f97\u66f4\u591a\u6d41\u91cf\uff0c\u5219\u8fd4\u56de</li> <li>\u4f7f\u7528\u7ea7\u522b\u56fe\u5728 G \u4e2d\u53d1\u9001\u591a\u4e2a\u6d41\uff0c\u76f4\u5230\u8fbe\u5230 \u963b\u585e\u6d41\u3002_\u8fd9\u91cc\u4f7f\u7528\u7ea7\u522b\u56fe\u610f\u5473\u7740\uff0c\u5728\u6bcf\u4e2a\u6d41\u4e2d\uff0c\u4ece s \u5230 t\uff0c\u8def\u5f84\u8282\u70b9\u7684\u7ea7\u522b\u5e94\u8be5\u662f 0\u30011\u30012\u2026\uff08\u6309\u987a\u5e8f\uff09\u3002</li> </ol> <p>\u65f6\u95f4\u590d\u6742\u5ea6 $O(EV^2)$ <pre><code>// C++ implementation of Dinic's Algorithm\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// A structure to represent a edge between\n// two vertex\nstruct Edge {\n    int v; // Vertex v (or \"to\" vertex)\n        // of a directed edge u-v. \"From\"\n        // vertex u can be obtained using\n        // index in adjacent array.\n\n    int flow; // flow of data in edge\n\n    int C; // capacity\n\n    int rev; // To store index of reverse\n            // edge in adjacency list so that\n            // we can quickly find it.\n};\n\n// Residual Graph\nclass Graph {\n    int V; // number of vertex\n    int* level; // stores level of a node\n    vector&lt;Edge&gt;* adj;\n\npublic:\n    Graph(int V)\n    {\n        adj = new vector&lt;Edge&gt;[V];\n        this-&gt;V = V;\n        level = new int[V];\n    }\n\n    // add edge to the graph\n    void addEdge(int u, int v, int C)\n    {\n        // Forward edge : 0 flow and C capacity\n        Edge a{ v, 0, C, (int)adj[v].size() };\n\n        // Back edge : 0 flow and 0 capacity\n        Edge b{ u, 0, 0, (int)adj[u].size() };\n\n        adj[u].push_back(a);\n        adj[v].push_back(b); // reverse edge\n    }\n\n    bool BFS(int s, int t);\n    int sendFlow(int s, int flow, int t, int ptr[]);\n    int DinicMaxflow(int s, int t);\n};\n\n// Finds if more flow can be sent from s to t.\n// Also assigns levels to nodes.\nbool Graph::BFS(int s, int t)\n{\n    for (int i = 0; i &lt; V; i++)\n        level[i] = -1;\n\n    level[s] = 0; // Level of source vertex\n\n    // Create a queue, enqueue source vertex\n    // and mark source vertex as visited here\n    // level[] array works as visited array also.\n    list&lt;int&gt; q;\n    q.push_back(s);\n\n    vector&lt;Edge&gt;::iterator i;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop_front();\n        for (i = adj[u].begin(); i != adj[u].end(); i++) {\n            Edge&amp; e = *i;\n            if (level[e.v] &lt; 0 &amp;&amp; e.flow &lt; e.C) {\n                // Level of current vertex is,\n                // level of parent + 1\n                level[e.v] = level[u] + 1;\n\n                q.push_back(e.v);\n            }\n        }\n    }\n\n    // IF we can not reach to the sink we\n    // return false else true\n    return level[t] &lt; 0 ? false : true;\n}\n\n// A DFS based function to send flow after BFS has\n// figured out that there is a possible flow and\n// constructed levels. This function called multiple\n// times for a single call of BFS.\n// flow : Current flow send by parent function call\n// start[] : To keep track of next edge to be explored.\n//       start[i] stores count of edges explored\n//       from i.\n// u : Current vertex\n// t : Sink\nint Graph::sendFlow(int u, int flow, int t, int start[])\n{\n    // Sink reached\n    if (u == t)\n        return flow;\n\n    // Traverse all adjacent edges one -by - one.\n    for (; start[u] &lt; adj[u].size(); start[u]++) {\n        // Pick next edge from adjacency list of u\n        Edge&amp; e = adj[u][start[u]];\n\n        if (level[e.v] == level[u] + 1 &amp;&amp; e.flow &lt; e.C) {\n            // find minimum flow from u to t\n            int curr_flow = min(flow, e.C - e.flow);\n\n            int temp_flow\n                = sendFlow(e.v, curr_flow, t, start);\n\n            // flow is greater than zero\n            if (temp_flow &gt; 0) {\n                // add flow to current edge\n                e.flow += temp_flow;\n\n                // subtract flow from reverse edge\n                // of current edge\n                adj[e.v][e.rev].flow -= temp_flow;\n                return temp_flow;\n            }\n        }\n    }\n\n    return 0;\n}\n\n// Returns maximum flow in graph\nint Graph::DinicMaxflow(int s, int t)\n{\n    // Corner case\n    if (s == t)\n        return -1;\n\n    int total = 0; // Initialize result\n\n    // Augment the flow while there is path\n    // from source to sink\n    while (BFS(s, t) == true) {\n        // store how many edges are visited\n        // from V { 0 to V }\n        int* start = new int[V + 1]{ 0 };\n\n        // while flow is not zero in graph from S to D\n        while (int flow = sendFlow(s, INT_MAX, t, start)) {\n\n            // Add path flow to overall flow\n            total += flow;\n        }\n\n        // Remove allocated array\n        delete[] start;\n    }\n\n    // return maximum flow\n    return total;\n}\n\n// Driver Code\nint main()\n{\n    Graph g(6);\n    g.addEdge(0, 1, 16);\n    g.addEdge(0, 2, 13);\n    g.addEdge(1, 2, 10);\n    g.addEdge(1, 3, 12);\n    g.addEdge(2, 1, 4);\n    g.addEdge(2, 4, 14);\n    g.addEdge(3, 2, 9);\n    g.addEdge(3, 5, 20);\n    g.addEdge(4, 3, 7);\n    g.addEdge(4, 5, 4);\n\n    // next exmp\n    /*g.addEdge(0, 1, 3 );\n    g.addEdge(0, 2, 7 ) ;\n    g.addEdge(1, 3, 9);\n    g.addEdge(1, 4, 9 );\n    g.addEdge(2, 1, 9 );\n    g.addEdge(2, 4, 9);\n    g.addEdge(2, 5, 4);\n    g.addEdge(3, 5, 3);\n    g.addEdge(4, 5, 7 );\n    g.addEdge(0, 4, 10);\n\n    // next exp\n    g.addEdge(0, 1, 10);\n    g.addEdge(0, 2, 10);\n    g.addEdge(1, 3, 4 );\n    g.addEdge(1, 4, 8 );\n    g.addEdge(1, 2, 2 );\n    g.addEdge(2, 4, 9 );\n    g.addEdge(3, 5, 10 );\n    g.addEdge(4, 3, 6 );\n    g.addEdge(4, 5, 10 ); */\n\n    cout &lt;&lt; \"Maximum flow \" &lt;&lt; g.DinicMaxflow(0, 5);\n    return 0;\n}\n</code></pre> Ford-</p>"},{"location":"SE_courses/FDS/#mst","title":"MST \u6700\u5c0f\u751f\u6210\u6811","text":"<p>\u6700\u5c0f\u751f\u6210\u6811(MST) \u6216\u5e26\u6743\u8fde\u901a\u65e0\u5411\u56fe\u7684\u6700\u5c0f\u6743\u91cd\u751f\u6210\u6811\u662f\u6743\u91cd\u5c0f\u4e8e\u6216\u7b49\u4e8e\u6240\u6709\u5176\u4ed6\u751f\u6210\u6811\u6743\u91cd\u7684\u751f\u6210\u6811\u3002</p>"},{"location":"SE_courses/FDS/#necessary-and-sufficient-condition-for-unique-mst","title":"Necessary-And-Sufficient-Condition-for-Unique-MST","text":"<p>Necessary-And-Sufficient-Condition-for-Unique-MSTLet \ud835\udc3a _be a connecte d weighted graph and _\ud835\udc47 a minimum spanning tree of \ud835\udc3a. Show that \ud835\udc47 is a unique minimum spanning tree if and only if the weight of each edge \ud835\udc52 _of _\ud835\udc3a that is not in \ud835\udc47 exceeds the weight of every other edge on the cycle in \ud835\udc47+\ud835\udc52 .</p> <ol> <li>Existence of Minimum Spanning Tree (MST):</li> <li>If the graph is connected, a minimum spanning tree always exists.</li> <li>For an undirected connected graph, the minimum spanning tree is a subset of edges that forms a tree connecting all vertices with the minimum possible total edge weight.</li> <li>Conditions for Existence:</li> <li>In a connected graph, a minimum spanning tree is guaranteed.</li> <li>If the graph is not connected, there won't be a minimum spanning tree [4].</li> <li>Algorithms:</li> <li>Kruskal's and Prim's algorithms are commonly used to find the minimum spanning tree of a connected graph.</li> </ol>"},{"location":"SE_courses/FDS/#prim","title":"Prim \u7b97\u6cd5","text":"<p>\u4ece\u5df2\u7ecf\u5728 MST \u91cc\u9762\u7684\u9876\u70b9\u4e2d\uff0c\u8fde\u63a5\u672a\u5728 MST \u4e2d\u7684\u9876\u70b9\uff0c\u4f7f\u5176\u8fb9\u6743\u6700\u5c0fStep 1: Determine an arbitrary vertex as the starting vertex of the MST.Step 2: Follow steps 3 to 5 till there are vertices that are not included in the MST (known as fringe vertex).Step 3: Find edges connecting any tree vertex with the fringe vertices.Step 4: Find the minimum among these edges.Step 5: Add the chosen edge to the MST if it does not form any cycle.Step 6: Return the MST and exit <pre><code>// A C program for Prim's Minimum\n// Spanning Tree (MST) algorithm. The program is\n// for adjacency matrix representation of the graph\n\n#include &lt;limits.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdio.h&gt;\n\n// Number of vertices in the graph\n#define V 5\n\n// A utility function to find the vertex with\n// minimum key value, from the set of vertices\n// not yet included in MST\nint minKey(int key[], bool mstSet[])\n{\n    // Initialize min value\n    int min = INT_MAX, min_index;\n\n    for (int v = 0; v &lt; V; v++)\n        if (mstSet[v] == false &amp;&amp; key[v] &lt; min)\n            min = key[v], min_index = v;\n\n    return min_index;\n}\n\n// A utility function to print the\n// constructed MST stored in parent[]\nint printMST(int parent[], int graph[V][V])\n{\n    printf(\"Edge \\tWeight\\n\");\n    for (int i = 1; i &lt; V; i++)\n        printf(\"%d - %d \\t%d \\n\", parent[i], i,\n            graph[i][parent[i]]);\n}\n\n// Function to construct and print MST for\n// a graph represented using adjacency\n// matrix representation\nvoid primMST(int graph[V][V])\n{\n    // Array to store constructed MST\n    int parent[V];\n    // Key values used to pick minimum weight edge in cut\n    int key[V];\n    // To represent set of vertices included in MST\n    bool mstSet[V];\n\n    // Initialize all keys as INFINITE\n    for (int i = 0; i &lt; V; i++)\n        key[i] = INT_MAX, mstSet[i] = false;\n\n    // Always include first 1st vertex in MST.\n    // Make key 0 so that this vertex is picked as first\n    // vertex.\n    key[0] = 0;\n\n    // First node is always root of MST\n    parent[0] = -1;\n\n    // The MST will have V vertices\n    for (int count = 0; count &lt; V - 1; count++) {\n\n        // Pick the minimum key vertex from the\n        // set of vertices not yet included in MST\n        int u = minKey(key, mstSet);\n\n        // Add the picked vertex to the MST Set\n        mstSet[u] = true;\n\n        // Update key value and parent index of\n        // the adjacent vertices of the picked vertex.\n        // Consider only those vertices which are not\n        // yet included in MST\n        for (int v = 0; v &lt; V; v++)\n\n            // graph[u][v] is non zero only for adjacent\n            // vertices of m mstSet[v] is false for vertices\n            // not yet included in MST Update the key only\n            // if graph[u][v] is smaller than key[v]\n            if (graph[u][v] &amp;&amp; mstSet[v] == false\n                &amp;&amp; graph[u][v] &lt; key[v])\n                parent[v] = u, key[v] = graph[u][v];\n    }\n\n    // print the constructed MST\n    printMST(parent, graph);\n}\n\n// Driver's code\nint main()\n{\n    int graph[V][V] = { { 0, 2, 0, 6, 0 },\n                        { 2, 0, 3, 8, 5 },\n                        { 0, 3, 0, 0, 7 },\n                        { 6, 8, 0, 0, 9 },\n                        { 0, 5, 7, 9, 0 } };\n\n    // Print the solution\n    primMST(graph);\n\n    return 0;\n}\n</code></pre> \u65f6\u95f4\u590d\u6742\u5ea6\uff1a$O(V^2)$\uff0c\u5982\u679c\u8f93\u5165\u56fe\u4f7f\u7528\u90bb\u63a5\u8868\u6765\u8868\u793a\uff0c\u90a3\u4e48\u501f\u52a9\u4e8c\u53c9\u5806\uff0cPrim\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u964d\u4f4e\u5230$O(E * logV)$\u3002\u5728\u8fd9\u4e2a\u5b9e\u73b0\u4e2d\uff0c\u6211\u4eec\u603b\u662f\u8003\u8651\u751f\u6210\u6811\u4ece\u56fe\u7684\u6839\u5f00\u59cb\u7a7a\u95f4\uff1a$O(V)$</p>"},{"location":"SE_courses/FDS/#kruskal","title":"Kruskal \u7b97\u6cd5","text":"<p>Kruskal\u2019s Minimum Spanning Tree (MST) Algorithm - GeeksforGeeks\u5728\u514b\u9c81\u65af\u5361\u5c14\u7b97\u6cd5\u4e2d\uff0c\u6309\u5347\u5e8f\u5bf9\u7ed9\u5b9a\u56fe\u7684\u6240\u6709\u8fb9\u8fdb\u884c\u6392\u5e8f\u3002\u5982\u679c\u65b0\u6dfb\u52a0\u7684\u8fb9\u4e0d\u5f62\u6210\u73af\uff0c\u5219\u7ee7\u7eed\u5728MST\u4e2d\u6dfb\u52a0\u65b0\u7684\u8fb9\u548c\u8282\u70b9\u3002\u5b83\u9996\u5148\u9009\u62e9\u6700\u5c0f\u52a0\u6743\u8fb9\uff0c\u6700\u540e\u9009\u62e9\u6700\u5927\u52a0\u6743\u8fb9\u3002\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u8bf4\u5b83\u5728\u6bcf\u4e00\u6b65\u4e2d\u90fd\u505a\u51fa\u5c40\u90e8\u6700\u4f18\u9009\u62e9\u4ee5\u627e\u5230\u6700\u4f18\u89e3\u3002\u56e0\u6b64\u8fd9\u662f\u4e00\u4e2a\u8d2a\u5a6a\u7b97\u6cd5\u3002</p> <ol> <li>\u6309\u6743\u91cd\u975e\u964d\u5e8f\u5bf9\u6240\u6709\u8fb9\u8fdb\u884c\u6392\u5e8f\u3002 </li> <li>\u9009\u62e9\u6700\u5c0f\u7684\u8fb9\u3002\u68c0\u67e5\u662f\u5426\u4e0e\u76ee\u524d\u5f62\u6210\u7684\u751f\u6210\u6811\u5f62\u6210\u73af\u3002\u5982\u679c\u672a\u5f62\u6210\u5faa\u73af\uff0c\u5219\u5305\u62ec\u8be5\u8fb9\u3002\u5426\u5219\uff0c\u4e22\u5f03\u5b83\u3002 </li> <li> <p>\u91cd\u590d\u6b65\u9aa42\uff0c\u76f4\u5230\u751f\u6210\u6811\u4e2d\u6709 (V-1) \u6761\u8fb9\u3002 <pre><code>// C++ program for the above approach \n\n#include &lt;bits/stdc++.h&gt; \nusing namespace std; \n\n// DSU data structure \n// path compression + rank by union \nclass DSU { \n    int* parent; \n    int* rank; \n\npublic: \n    DSU(int n) \n    { \n        parent = new int[n]; \n        rank = new int[n]; \n\n        for (int i = 0; i &lt; n; i++) { \n            parent[i] = -1; \n            rank[i] = 1; \n        } \n    } \n\n    // Find function \n    int find(int i) \n    { \n        if (parent[i] == -1) \n            return i; \n\n        return parent[i] = find(parent[i]); \n    } \n\n    // Union function \n    void unite(int x, int y) \n    { \n        int s1 = find(x); \n        int s2 = find(y); \n\n        if (s1 != s2) { \n            if (rank[s1] &lt; rank[s2]) { \n                parent[s1] = s2; \n            } \n            else if (rank[s1] &gt; rank[s2]) { \n                parent[s2] = s1; \n            } \n            else { \n                parent[s2] = s1; \n                rank[s1] += 1; \n            } \n        } \n    } \n}; \n\nclass Graph { \n    vector&lt;vector&lt;int&gt; &gt; edgelist; \n    int V; \n\npublic: \n    Graph(int V) { this-&gt;V = V; } \n\n    // Function to add edge in a graph \n    void addEdge(int x, int y, int w) \n    { \n        edgelist.push_back({ w, x, y }); \n    } \n\n    void kruskals_mst() \n    { \n        // Sort all edges \n        sort(edgelist.begin(), edgelist.end()); //\u8fb9\u6392\u5e8f\n\n        // Initialize the DSU \n        DSU s(V); \n        int ans = 0; \n        cout &lt;&lt; \"Following are the edges in the \"\n                \"constructed MST\"\n            &lt;&lt; endl; \n        for (auto edge : edgelist) { \n            int w = edge[0]; \n            int x = edge[1]; \n            int y = edge[2]; \n\n            // Take this edge in MST if it does \n            // not forms a cycle \n            if (s.find(x) != s.find(y)) { \n                s.unite(x, y); \n                ans += w; \n                cout &lt;&lt; x &lt;&lt; \" -- \" &lt;&lt; y &lt;&lt; \" == \" &lt;&lt; w \n                    &lt;&lt; endl; \n            } \n        } \n        cout &lt;&lt; \"Minimum Cost Spanning Tree: \" &lt;&lt; ans; \n    } \n}; \n\n// Driver code \nint main() \n{ \n    Graph g(4); \n    g.addEdge(0, 1, 10); \n    g.addEdge(1, 3, 15); \n    g.addEdge(2, 3, 4); \n    g.addEdge(2, 0, 6); \n    g.addEdge(0, 3, 5); \n\n    // Function call \n    g.kruskals_mst(); \n\n    return 0; \n}\n</code></pre> \u65f6\u95f4\u590d\u6742\u5ea6\uff1a$O(E * logE)$ \u6216 $O(E * logV)$ </p> </li> <li> <p>\u8fb9\u6392\u5e8f\u9700\u8981 $O(E * logE)$ \u65f6\u95f4\u3002 </p> </li> <li>\u6392\u5e8f\u540e\uff0c\u6211\u4eec\u8fed\u4ee3\u6240\u6709\u8fb9\u5e76\u5e94\u7528\u67e5\u627e\u5e76\u96c6\u7b97\u6cd5\u3002\u67e5\u627e\u548c\u5e76\u96c6\u64cd\u4f5c\u6700\u591a\u9700\u8981 $O(logV)$ \u65f6\u95f4\u3002</li> <li>\u6240\u4ee5\u603b\u4f53\u590d\u6742\u5ea6\u662f $O(E * logE + E * logV)$ \u65f6\u95f4\u3002 </li> <li>E\u7684\u503c\u6700\u591a\u53ef\u4ee5\u662fO(V 2 )\uff0c\u56e0\u6b64O(logV)\u548cO(logE)\u662f\u76f8\u540c\u7684\u3002\u56e0\u6b64\uff0c\u603b\u4f53\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(E * logE)$\u6216 $O(E*logV)$</li> </ol>"},{"location":"SE_courses/FDS/#dfs","title":"DFS \u6df1\u5ea6\u4f18\u5148\u641c\u7d22","text":"<ol> <li>\u6700\u521d\u5806\u6808\u548c\u8bbf\u95ee\u6570\u7ec4\u90fd\u662f\u7a7a\u7684\u3002</li> <li>\u8bbf\u95ee\u67d0\u4e00\u8282\u70b9\uff0c\u5c06\u5176\u672a\u8bbf\u95ee\u8fc7\u7684\u76f8\u90bb\u8282\u70b9\u653e\u5165\u6808\u4e2d\u3002</li> <li>\u8bbf\u95ee\u6808\u9876\u5e76\u5c06\u5176\u4ece\u6808\u4e2d\u5f39\u51fa\uff0c\u5e76\u5c06\u5176\u6240\u6709\u672a\u8bbf\u95ee\u7684\u76f8\u90bb\u8282\u70b9\u653e\u5165\u6808\u4e2d\u3002</li> <li>\u91cd\u590d\u6b65\u9aa4 3 \u76f4\u5230\u6808\u53d8\u7a7a\uff0cDFS \u7ed3\u675f</li> </ol>"},{"location":"SE_courses/FDS/#find-articulation-point","title":"Find articulation point \u627e\u5272\u70b9","text":""},{"location":"SE_courses/FDS/#strongly-connected-components","title":"Strongly Connected Components \u5f3a\u8fde\u901a\u7ec4\u4ef6","text":""},{"location":"SE_courses/FDS/#tarjan","title":"Tarjan \u7b97\u6cd5 \u627e\u5272\u70b9\uff1f\u8fd8\u662f\u5f3a\u8fde\u901a\u7ec4\u4ef6","text":"<p>DFS+\u6808\u5b9e\u73b0\u54d4\u54e9\u54d4\u54e9\u89c6\u9891\u53c2\u8003 <pre><code>#include&lt;malloc.h&gt;\ntypedef struct VNode *PtrToVNode;\nstruct VNode {\n    Vertex Vert;\n    PtrToVNode Next;\n};\ntypedef struct GNode *Graph;\nstruct GNode {\n    int NumOfVertices;\n    int NumOfEdges;\n    PtrToVNode *Array;\n};\n\nint count=0;\n#define min(a,b) (((a)&lt;(b))?(a):(b))\nvoid find(Graph G, Vertex v, int num[],int low[], PtrToVNode stack, int visited[]);\nvoid push(int x, PtrToVNode s);\nint top(PtrToVNode s);\nvoid pop(PtrToVNode s);\nvoid StronglyConnectedComponents( Graph G, void (*visit)(Vertex V) ){\n    int low[MaxVertices]={0};\n    int visited[MaxVertices]={0};\n    int num[MaxVertices]={0};\n    PtrToVNode stack;\n    stack=malloc(sizeof(struct VNode));\n    for (int i = 0; i &lt; G-&gt;NumOfVertices; i++) {\n        if (num[i] == 0) {\n            find(G, i,num,low,stack,visited);\n        }\n    }\n}\nvoid find(Graph G, Vertex v, int num[],int low[], PtrToVNode stack, int visited[]){\n    visited[v]=1;\n    num[v] = low[v] = count++;\n    push(v,stack);\n    PtrToVNode w;\n    for(w=G-&gt;Array[v];w!=NULL;w=w-&gt;Next){\n        if(!num[w-&gt;Vert]){\n            find(G,w-&gt;Vert,num,low,stack,visited);\n\n            low[v]=min(low[v],low[w-&gt;Vert]);\n        }\n        else if(visited[w-&gt;Vert]){\n                low[v]=min(low[v],num[w-&gt;Vert]);\n            }\n\n    }\n    if(num[v]==low[v] ){\n        int t;\n        while(1){\n            if(t!=v ){\n                t=top(stack);\n                pop(stack);\n                visited[t]=0;\n                printf(\"%d \",t);\n            }else {\n                printf(\"\\n\");\n                break;\n            }\n        }\n\n    }\n}\nvoid push(int x, PtrToVNode s){\n    PtrToVNode tmp;\n    tmp=malloc(sizeof(struct VNode));\n    if(tmp!=NULL){\n        tmp-&gt;Vert=x;\n        tmp-&gt;Next=s-&gt;Next;\n        s-&gt;Next=tmp;\n    }\n}\nint top(PtrToVNode s){\n    if(s-&gt;Next!=NULL){\n        return s-&gt;Next-&gt;Vert;\n    }\n    return 0;\n}\nvoid pop(PtrToVNode s){\n    PtrToVNode a;\n    a=malloc(sizeof(struct VNode));\n    if(s-&gt;Next!=NULL){\n        a=s-&gt;Next;\n        s-&gt;Next=s-&gt;Next-&gt;Next;\n        free(a);\n    }\n}\n</code></pre> \u65f6\u95f4\u590d\u6742\u5ea6\uff1a$O(E+V)$\u90bb\u63a5\u8868\uff1b$O(V^2)$\u90bb\u63a5\u77e9\u9635</p>"},{"location":"SE_courses/FDS/#q_7","title":"Q","text":"<ol> <li>If an undirected graph G = (V, E) contains 10 vertices. Then to guarantee that G is connected in any cases, there has to be at least __ edges. \uff1f</li> <li>45</li> <li>37</li> <li>36</li> <li>9</li> <li>Which of the following statements is TRUE about topological sorting?</li> <li>If a graph has a topological sequence, then its adjacency matrix must be triangular.</li> <li>If the adjacency matrix is triangular, then the corresponding directed graph must have a unique topological sequence.</li> <li>In a DAG, if for any pair of distinct vertices Vi and Vj, there is a path either from Vi to Vj or from Vj to Vi, then the DAG must have a unique topological sequence.</li> <li>If Vi precedes Vj in a topological sequence, then there must be a path from Vi to V</li> <li>Let P be the shortest path from S to T. If the weight of every edge in the graph is incremented by 2, P will still be the shortest path from S to T.  F</li> </ol> <ol> <li>The minimum spanning tree of any connected weighted graph: \u4efb\u610f\u8fde\u901a\u52a0\u6743\u56fe\u7684\u6700\u5c0f\u751f\u6210\u6811C.may not be unique</li> <li>Apply DFS to a directed acyclic graph\uff08\u6709\u5411\u65e0\u5708\u56fe\uff09, and output the vertex before the end of each recursion. The output sequence will be:</li> </ol> <p>C.reversely topologically sorted</p> <ol> <li>Graph G is an undirected completed graph of 20 nodes. Is there an Euler circuit in G? If not, in order to have an Euler circuit, what is the minimum number of edges which should be removed from G?</li> </ol> <p>Each Node has exactly 19 degrees</p> <ul> <li>Euler Circuit (Strong Form) requires every node to be even degrees</li> <li>Euler Tour (Weak Form) requires 0 or 2 odd degrees</li> </ul> <p>Remove 1 edge, every 2 nodes will lose 1 degrees, so we lose 10 edges</p>"},{"location":"SE_courses/FDS/#_6","title":"FDS","text":""},{"location":"SE_courses/FDS/#questions","title":"Questions","text":""},{"location":"SE_courses/FDS/#homework","title":"homework","text":"<ol> <li>For a sequentially stored linear list of length N, the time complexities for deleting the first element and inserting the last element are ~~O(1) and O(N)~~, respectively.      F O(N) and O(1)</li> <li>\u987a\u5e8f\u5b58\u50a8\u7684\u7ebf\u6027\u8868\u652f\u6301\u968f\u673a\u5b58\u53d6\uff0c\u6240\u4ee5\u67e5\u8be2\u7684\u65f6\u95f4\u662f\u5e38\u6570\u65f6\u95f4\uff0c\u4f46\u63d2\u5165\u9700\u8981\u628a\u540e\u9762\u6bcf\u4e00\u4e2a\u5143\u7d20\u7684\u4f4d\u7f6e\u90fd\u8fdb\u884c\u8c03\u6574\uff0c\u6240\u4ee5\u662f\u7ebf\u6027\u65f6\u95f4\u3002 \u63d2\u5165\u6700\u540e\u4e00\u4e2a\u65f6\u95f4\u4e3aO(1).</li> <li>\u5faa\u73af\u961f\u5217\u6ee1\u65f6rear == front -1. enqueue\u65f6 rear \u589e\u52a0, dequeue front \u589e\u52a0.</li> <li>To insert s after p in a doubly linked circular list, we must do: <ul> <li>A. p-&gt;next=s; s-&gt;prior=p; p-&gt;next-&gt;prior=s ; </li> <li>B. p-&gt;next-&gt;prior=s; p-&gt;next=s; s-&gt;prior=p; s-&gt;next=p-&gt;next;</li> <li>C. s-&gt;prior=p; s-&gt;next=p-&gt;next; p-&gt;next=s; p-&gt;next-&gt;prior=s;</li> <li>D. s-&gt;prior=p; s-&gt;next=p-&gt;next; p-&gt;next-&gt;prior=s; p-&gt;next=s;</li> </ul> </li> <li>It is always possible to represent a tree by a one-dimensional integer array. T</li> <li>It is always possible to represent a tree by a one-dimensional integer array using various techniques such as breadth-first or depth-first traversal.</li> <li> <p>If a general tree T is converted into a binary tree BT, then which of the following BT traversals gives the same sequence as that of the post-order traversal of T?</p> <ul> <li>A. Pre-order traversal</li> <li>B. In-order traversal</li> <li>C. Post-order traversal</li> <li>D. Level-order traversal T\u7684preorder = BT\u7684preorderT\u7684postorder = BT\u7684inorder</li> </ul> </li> <li> <p>Among the following threaded binary trees (the threads are represented by dotted curves), which one is the postorder threaded tree?</p> </li> </ol> <p> \u7ebf\u7d22\u4e8c\u53c9\u6811\u4e2d\uff0c\u5de6\u7ebf\u7d22\u4e3a\u4e0a\u4e00\u4e2a\u7ed3\u70b9\uff0c\u53f3\u7ebf\u7d22\u4e3a\u4e0b\u4e00\u4e2a\u7ed3\u70b9\u540e\u5e8f\uff1a\u5de6\u53f3\u6839\u4e2d\u5e8f\uff1a\u5de6\u6839\u53f3\u524d\u5e8f\uff1a\u6839\u5de6\u53f3</p> <ol> <li>Suppose that an array of size 6 is used to store a circular queue, and the values of front and rear are 0 and 4, respectively. Now after 2 dequeues and 2 enqueues, what will the values of front and rear be?</li> <li>2 and 0</li> <li>2 and 2</li> <li>2 and 4</li> <li>2 and 6</li> <li>\u5934\u662f 0 \u800c\u4e0d\u662f 6</li> <li>Suppose that an array of size m is used to store a circular queue. If the head pointer front and the current size variable size are used to represent the range of the queue instead of front and rear, then the maximum capacity of this queue can be: (5\u5206)</li> <li>m-1</li> <li>m</li> <li>m+1</li> <li>cannot be determined</li> <li>\u5c31\u662f\u6570\u7ec4\u7684\u5927\u5c0f</li> </ol>"},{"location":"SE_courses/FDS/#midterm","title":"Midterm","text":"<ol> <li>The time comlexity of Selection Sort will be the same no matter we store the elements in an array or a linked list. T</li> <li>If N numbers are stored in a singly linked list in increasing order, then the average time complexity for binary search is O(logN). F \u94fe\u8868\u662f\u4e0d\u80fd\u4f7f\u7528\u6298\u534a\u67e5\u627e\u7684</li> <li>The time complexity of Selection Sort will be the same no matter we store the elements in an array or a linked list. T</li> <li>If a stack is used to convert the infix expression a+bc+(de+f)*g into a postfix expression, what will be in the stack (listing from the bottom up) when f is read?</li> <li>+(+</li> <li>+(*+</li> <li>abcde</li> <li>++(+</li> </ol> <p>\u4e2d\u7f00\u8868\u8fbe\u5f0f\u8f6c\u5316\u4e3a\u540e\u7f00\u8868\u8fbe\u5f0f\uff0c\u8f6c\u5316\u7684\u7b97\u6cd5\u5982\u4e0b\uff1a</p> <ul> <li>\u521d\u59cb\u5316\u4e00\u4e2a\u6808</li> <li>\u9010\u4e2a\u8bfb\u53d6\u5143\u7d20\uff08\u6570\u5b57\u6216\u8005\u64cd\u4f5c\u7b26\uff09</li> <li>\u5982\u679c\u9047\u5230\u6570\u5b57\uff0c\u76f4\u63a5\u8f93\u51fa</li> <li>\u5982\u679c\u9047\u5230\u64cd\u4f5c\u7b26\uff08\u4e0d\u8003\u8651\u62ec\u53f7\uff09\uff0c\u5982\u679c\u5176\u4f18\u5148\u7ea7\u5927\u4e8e\u6808\u9876\u5143\u7d20\uff0c\u5c31\u5c06\u6808\u9876\u5f39\u51fa\uff0c\u5e76\u91cd\u590d\u6b64\u6b65\u9aa4\uff0c\u5426\u5219\u5c06\u8be5\u64cd\u4f5c\u7b26\u538b\u5165\u6808\u4e2d\uff08\u6808\u4e3a\u7a7a\u7684\u65f6\u5019\u4e5f\u76f4\u63a5\u538b\u6808\u5373\u53ef\uff09</li> <li>\u5982\u679c\u9047\u5230\u5de6\u62ec\u53f7\"(\"\uff0c\u76f4\u63a5\u5c06\u5176\u538b\u5165\u6808\u4e2d\uff0c\u5982\u679c\u9047\u5230\u53f3\u62ec\u53f7\")\"\uff0c\u5faa\u73af\u5f39\u51fa\u9876\u6808\u5143\u7d20\uff0c\u76f4\u5230\u5de6\u62ec\u53f7\u4e3a\u6b62\uff08\u5de6\u62ec\u53f7\u4e5f\u9700\u8981\u5f39\u51fa\uff0c\u53f3\u62ec\u53f7\u4e0d\u9700\u8981\u538b\u6808\uff09\uff0c\u5e76\u4e14\u8f93\u51fa\u6240\u6709\u88ab\u5f39\u6808\u9876\u5143\u7d20\uff08\u5de6\u62ec\u53f7\u9664\u5916\uff09</li> <li>Suppose that a polynomial\uff08\u591a\u9879\u5f0f\uff09 is represented by a linked list storing its non-zero terms. Given two polynimials with N1 and N2 non-zero terms, and the highest exponents being M1 and M2, respectively. Then the time complexity for adding them up is:</li> <li>O(N1\u00d7N2)</li> <li>O(N1+N2)</li> <li>O(M1\u00d7M2)</li> <li>O(M1+M2)</li> <li></li> </ul>"},{"location":"SE_courses/FDS/#pta-code","title":"Pta code","text":""},{"location":"SE_courses/FDS/#true-or-flase","title":"True or Flase","text":"<p>\u7b97\u6cd5\u7ade\u8d5b\u57fa\u7840\u8bad\u7ec3\u9898_\u5224\u65ad\u9898_it is always possible to represent a tree by a one_\u767d\u672f_\u7af9\u82d3\u7684\u535a\u5ba2-CSDN\u535a\u5ba2</p>"},{"location":"SE_courses/FDS/#function","title":"function","text":"<p><pre><code>List Reverse( List L ){\n    List head,node,temp;\n    node=L-&gt;Next;\n    while(node){\n        temp=node-&gt;Next;\n        node-&gt;Next=head;\n        head=node;\n        node=temp;\n    }\n    L-&gt;Next=head;\n    return L;\n}\n\n\ntypedef struct Node *PtrToNode;\ntypedef PtrToNode List;\ntypedef PtrToNode Position;\nstruct Node {\n    ElementType Element;\n    Position Next;\n};\n</code></pre> The function Reverse is supposed to return the reverse linked list of L, with a dummy header.</p> <pre><code>Polynomial Add( Polynomial a, Polynomial b ){\n    Polynomial head,temp,node;\n    if(a==NULL) return b;\n    if(b==NULL) return a;\n    node=(Polynomial)malloc(sizeof(Polynomial));\n    head=node;\n    a=a-&gt;Next;\n    b=b-&gt;Next;\n    while(b &amp;&amp; a){\n        temp=(Polynomial)malloc(sizeof(Polynomial));\n\n        if(b-&gt;Exponent &gt; a-&gt;Exponent){\n            temp-&gt;Coefficient=b-&gt;Coefficient;\n            temp-&gt;Exponent=b-&gt;Exponent;\n            b=b-&gt;Next;\n        }else if(b-&gt;Exponent &lt; a-&gt;Exponent){\n            temp-&gt;Coefficient=a-&gt;Coefficient;\n            temp-&gt;Exponent=a-&gt;Exponent;\n            a=a-&gt;Next;\n        }else{\n            temp-&gt;Coefficient=a-&gt;Coefficient + b-&gt;Coefficient;\n            temp-&gt;Exponent=a-&gt;Exponent;\n            a=a-&gt;Next;\n            b=b-&gt;Next;\n            if(temp-&gt;Coefficient==0) continue;\n        }\n        temp-&gt;Next=NULL;\n        node-&gt;Next=temp;\n        node=temp;\n    }\n    if(a) node-&gt;Next=a;\n    if(b) node-&gt;Next=b;\n    return head;\n}\n\ntypedef struct Node *PtrToNode;\nstruct Node {\n    int Coefficient;\n    int Exponent;\n    PtrToNode Next;\n};\ntypedef PtrToNode Polynomial;\n/* Nodes are sorted in decreasing order of exponents.*/  \n</code></pre> <p><pre><code>void Print_NLT( Tree T,  int X ){\n    if(T == NULL)return;//\u5982\u679c\u6811\u4e3a\u7a7a\uff0c\u8fd4\u56denull\n\n    //\u76f4\u63a5\u8fdb\u884c\u6811\u7684\u904d\u5386\uff0c\u56e0\u4e3a\u662f\u4ece\u5927\u5230\u5c0f\u8f93\u51fa\u4e0d\u5c0f\u4e8eX\u7684\u6570\n    //\u6240\u4ee5\u5148\u904d\u5386\u53f3\u5b50\u6811\uff0c\u5927\u4e8eX\u7684\u76f4\u63a5\u8f93\u51fa\uff0c\u518d\u904d\u5386\u5de6\u5b50\u6811.\n    Print_NLT(T-&gt;Right,X);\n    if(T-&gt;Element&gt;=X){\n        printf(\"%d \",T-&gt;Element);\n    }\n    Print_NLT(T-&gt;Left,X);\n\n}\n</code></pre> <pre><code>int Isomorphic( Tree T1, Tree T2 ){\n    if(T1==NULL &amp;&amp; T2==NULL)return 1;\n    if((T1==NULL&amp;&amp;T2!=NULL)||(T1!=NULL&amp;&amp;T2==NULL))return 0;\n    else if(T1-&gt;Element != T2-&gt;Element)return 0;\n    return (Isomorphic(T1-&gt;Left,T2-&gt;Left)&amp;&amp;Isomorphic(T1-&gt;Right,T2-&gt;Right)) || (Isomorphic(T1-&gt;Right,T2-&gt;Left)&amp;&amp;Isomorphic(T1-&gt;Left,T2-&gt;Right));\n}\n</code></pre> <pre><code>void PercolateUp( int p, PriorityQueue H )\n{\n    while (H-&gt;Elements[p] &lt; H-&gt;Elements[p/2] &amp;&amp; p&gt;1)\n    {\n        int temp;\n        temp=H-&gt;Elements[p];\n        H-&gt;Elements[p]=H-&gt;Elements[p/2];\n        H-&gt;Elements[p/2]=temp;\n        p /=2;\n    } \n}\n\nvoid PercolateDown( int p, PriorityQueue H )\n{\n    while (H-&gt;Elements[p] &gt; H-&gt;Elements[p*2] &amp;&amp; 2*p &lt;= H-&gt;Size )\n    {\n        int temp;\n        temp=H-&gt;Elements[p];\n        H-&gt;Elements[p]=H-&gt;Elements[p*2];\n        H-&gt;Elements[p*2]=temp;\n        p *=2;\n    } \n}\n</code></pre></p>"},{"location":"SE_courses/OOP/","title":"OOP","text":"<p>zzz</p>"},{"location":"other/IELTs/","title":"IELTs","text":""},{"location":"other/IELTs/#speaking","title":"Speaking","text":""},{"location":"other/IELTs/#part-1","title":"Part 1","text":"<p>1. Paying bills     What kind of bills do you have to pay?     How do you usually pay your bills? Why?     Is there anything you could do to make your bills cheaper?</p>"},{"location":"other/IELTs/#part-2","title":"Part 2","text":"<p>1. Describe a successful business person you know     you should say who's the person is     how you knew him/her     what business he or she does     and explain why he or she is success</p> <p>Ah, let's talk about a classic example: Steve Jobs. He's a well-known figure, the co-founder of Apple Inc. I never met him personally, but his story is quite famous. Jobs started Apple in a garage with his friend Steve Wozniak. Their big breakthrough was the Apple II, one of the first highly successful mass-produced personal computers.Jobs was known for his perfectionism, innovative mindset, and ability to foresee market trends. He wasn't just about technology; he cared deeply about design and user experience. This unique blend made Apple products not just gadgets but lifestyle statements.Despite facing setbacks \u2013 like being ousted from Apple in the 1980s \u2013 he returned in the 1990s, leading the company to create groundbreaking products like the iPod, iPhone, and iPad. He was successful because he wasn't afraid to take risks and he always pushed for what he believed in, even when others doubted him. Remember, \"The people who are crazy enough to think they can change the world are the ones who do.\" That's a quote from Jobs himself.</p> <p>2. Describe some food or drink that you learned to prepare     what food or drink you learned to prepare     when and where you learned     how you learned     and explain how you felt about learning to prepare</p> <p>Learning to prepare a steak is an experience that I will always remember fondly. It all started twoyears ago when I decided to fry my hand at cooking a steak in my apartment kitchen. Havingalways enjoyed eating steaks, I was eager to learn how to prepare one myself. To get started, I scoured the internet for helpful tips and tricks on cooking the perfect steak. I came across some popular celebrity chef videos, including Gordon Ramsay's tutorial on how tocook a steak. Watching his videos helped me get the hang of the cooking process and learn someessential techniques. So, I headed to the local market and picked up a nice ribeye steak. Following Ramsay's advice, Iseasoned it generously with salt and pepper, rubbing it in to really bring out the flavor. Next, I preheated a cast-iron skillet on high heat and added a pat of butter and a drizzle of oliveoil. Once the skillet was nice and hot, I carefully placed the steak on it, and the sizzling soundwas music to my ears. I let it cook for 3 to 4 minutes on each side, using tongs to turn it over and basting it with the melted butter to make it extra juicy and delicious. Once the steak was done, I took it off the skillet and let it rest on a cutting board for a few minutesto let the juices redistribute and make it even more tender. Then, I sliced it against the grain intothin slices and served it up with some tasty vegetables, including crisp-tender asparagus andmushrooms. Overall, learning to prepare a steak was an exhilarating experience. I was proud of myself forgetting on to the ropes and mastering this new skill, and I enjoyed the satisfaction of creating adelicious meal that I could share with others.</p>"},{"location":"other/IELTs/#part-3","title":"Part 3","text":"<p>1. Young people and cooking</p>"},{"location":"other/IELTs/#writing","title":"Writing","text":""},{"location":"other/IELTs/#task-1","title":"Task 1","text":"<p>1. Percentage of population in living cities</p> <p>This line graph illustrates the proportion of urban citizens in Philippines, Malaysia, Thailand and Indonesia between 1970 and 2020, with the expected population in 2030 and 2040.</p> <p>Overall, it can be easily seen from the graph that all four countries has a dramatic rise in population, starting at the lowest point in 1970 and being projected to reach the peak in 2040.</p> <p>Malaysia starts at 30%, about twice as much as Indonesia. After that, both showed an obvious increase, with the former rising to approximately 76% in 2020, and the latter rising to approximately 50%. Both sides are expected to continue rising thereafter, with Malaysia slowly rising to about 83%, while Indonesia is expected to see a 12% gain.</p> <p>The starting point of Philippines is about 31%, which is about 13% higher than Thailand. Over the next decade, the Philippines remained relatively stable. Between 1980 and 1990, the Philippines rose to about 48%, but fell to about 42% over the next 20 years. During this period, Thailand showed a gradual increase from 18% to approximately 30%. After 2010, both countries are expected to show an upward trend, rising to 55% and 49% respectively.</p> <p>2. Number of US household in millions by their annual income</p> <p>This bar chart illustrates the numbers of US household in millions by their annual income in 2007, 2011 and 2015 respectively.</p> <p>Overall, it can be easily seen that households of $100000 or more climbs apparently and is the most, while other remain nearly steady, with $25000-$49999 the second, followed by less than $25000 and the $50000-$74999, and the $75000-$99999 the last.</p> <p>From the graph, less than $25000 and $25000-$49999 first rise in 2011 and sightly fall in 2015, from 25 to 29 to 28 and 27 to 30 to 29 respectively. While $75000-$99999 and $100000 or more are the other way around, beginning at 14.5 and 29.5, decreasing to 14 and 27 and ending with 15 and 33. The middle bar, namely $50000-$74999 remains level in the three years, roughly 21.</p> <p>In 2011, the bars of $25000-$49999 and less than $25000 exceed $100000 or more at a marginal edge. But the $100000 or more has witnessed a dramatic increase in 2015, approximately from the lowest point 27 to 33.</p>"},{"location":"other/IELTs/#task-2","title":"Task 2","text":"<p>1. The most important aim of science should be to improve people's lives. To what extent do you agree or disagree with this statement?</p> <p>The proposition that the most important aim of science should be to improve people's lives is a significant one, meriting thoughtful consideration. This essay will argue that, while the improvement of human lives is a crucial goal of science, it should not be viewed as its sole purpose.</p> <p>Firstly, the advancement of human welfare through scientific discovery has undeniably been monumental. Medical science, for instance, has dramatically enhanced the quality and longevity of life. The development of vaccines, antibiotics, and advanced surgical techniques has transformed healthcare, drastically reducing mortality rates and improving the management of chronic diseases. Moreover, technological innovations, a product of scientific research, have reshaped daily life, offering unparalleled convenience and efficiency. The advent of the internet, smartphones, and smart home technology are prime examples of how science has made everyday tasks more accessible and interconnected.</p> <p>However, the pursuit of science for the sheer expansion of knowledge should also be recognized as an essential aim. Many scientific endeavors, such as space exploration or the study of fundamental physics, may not have immediate practical applications but are crucial for our understanding of the universe. The pursuit of such knowledge can lead to unforeseen benefits. For example, the exploration of space has led to the development of satellite communication, GPS technology, and numerous other applications that have had a considerable impact on daily life.</p> <p>Furthermore, it's important to consider the ethical and societal implications of focusing solely on science that improves human life. Such a focus might lead to the neglect of crucial environmental or ecological research, which may not have direct benefits for humans in the short term but are essential for the sustainability of life on Earth. Additionally, this approach might bias funding and attention towards projects with immediate commercial benefits, potentially at the expense of basic science research.</p> <p>In conclusion, while improving human lives is a vital goal of scientific endeavor, it should not be the only aim. The pursuit of knowledge for its own sake and the exploration of questions beyond immediate human concerns are equally important. This broader perspective ensures a balanced approach to science, where the pursuit of understanding and the betterment of humanity go hand in hand.</p> <p>2.Some university students want to learn about other subjects in addition to their main subjects. Others believe it is more important to give all their time and attention to studying for a qualification.</p> <p>3. In many countries, people are now living longer than ever before. Some people say an ageing population creates problems for governments. Other people think there are benefits if society has more elderly people. To what extent do the advantages of having an ageing population outweigh the disadvantages?</p> <p>In the contemporary era, the phenomenon of an aging population has become increasingly prominent across the globe, thanks to advancements in medical technology and improvements in living standards. While some argue that this trend poses significant challenges to societies and governments, I contend that the benefits of an aging population far outweigh its disadvantages, heralding a more sustainable and wisdom-oriented future.</p> <p>On the one hand, critics of demographic aging often highlight the economic and social strains it imposes. Primarily, the increasing number of elderly individuals elevates the demand for pensions and healthcare services, potentially straining public finances and placing a heavier burden on the younger working-age population. Furthermore, a shrinking workforce could lead to decreased productivity and economic stagnation. These concerns, while valid, overlook the evolving nature of modern economies and the adaptability of social systems.</p> <p>Conversely, the advantages of an aging population are manifold and, in my opinion, eclipse the aforementioned challenges. Firstly, elderly individuals contribute significantly to society through the transfer of knowledge and skills, mentoring younger generations and fostering a culture of wisdom and experience. Their active participation in volunteer work and the informal economy also adds substantial value, often unaccounted for in traditional economic metrics.</p> <p>Moreover, the aging demographic drives innovation and growth in critical sectors. The healthcare and eldercare industries, for example, are prompted to advance in terms of services and technologies, ranging from personalized medicine to smart home systems, thereby creating new employment opportunities and stimulating economic vitality. This not only enhances the quality of life for the elderly but also benefits society as a whole by accelerating technological and medical advancements.</p> <p>Additionally, an aging society encourages a shift towards more sustainable living practices. As populations age, there tends to be a decrease in resource-intensive consumption patterns, aligning more closely with environmental sustainability goals. This demographic shift can thus act as a catalyst for societies to adopt greener lifestyles and policies, contributing to the global effort against climate change.</p> <p>In conclusion, while the aging population presents certain challenges, these are not insurmountable. With strategic planning and policy adjustments, societies can harness the potential benefits of this demographic trend. The wealth of experience and knowledge that older individuals offer, combined with the stimulus they provide for innovation and sustainability, underscores the positive aspects of an aging society. Therefore, it is clear that the advantages of having an aging population significantly outweigh the disadvantages, marking a pivotal step towards a more sustainable and enlightened future.</p> <p>4. In many countries around the world, rural people are moving to cities, so the population in the countryside is decreasing. Do you think this is a positive or a negative development?</p> <p>In numerous nations worldwide, the trend of rural populations migrating to urban areas is prominent, leading to a dwindling number of inhabitants in the countryside. This shift, in my opinion, embodies a double-edged sword, reflecting the complex dynamics of societal evolution.</p> <p>On the one hand, the allure of cities is undeniable. Urban centers, with their advanced infrastructure and abundant employment prospects, magnetize individuals seeking improved livelihoods. The superior quality of urban life, coupled with the automation of agricultural practices reducing rural labor demand, underscores the rationality behind this migration. Such developments signify progress, offering individuals the freedom to pursue a broader spectrum of opportunities.</p> <p>On the other hand, this influx into urban areas introduces several challenges. Skyrocketing housing prices, escalating traffic congestion, rising unemployment rates, and deteriorating living conditions due to pollution are immediate repercussions. Moreover, the urban expansion necessitates converting more land into cityscapes, potentially straining resources. The diminished rural workforce and reduced agricultural lands could hinder food production, highlighting a critical balance between consumption and production that must be maintained.</p> <p>Yet, the phenomenon of urbanization is not a one-way street. The concept of reverse urbanization, where individuals return to rural areas seeking respite from urban chaos, illustrates a natural recalibration process. This cycle suggests that concerns regarding urban overpopulation and rural depopulation may eventually equilibrate.</p> <p>Hence, viewing rural-to-urban migration through a binary lens of positive or negative oversimplifies its implications. This movement is an intrinsic aspect of societal advancement, where the intertwined challenges and benefits will ultimately pave the way for a balanced development.</p>"},{"location":"other/test/","title":"Test","text":"<p>\u8fd9\u662f note \u7c7b\u578b\u7684\u63d0\u793a\u6846</p> <p>\u63d0\u793a\uff1a\u66f4\u591a\u7cbe\u5f69\u5185\u5bb9\u8bb0\u5f97\u5173\u6ce8\u6211\u554a</p> <p>\u8fd9\u662f success \u7c7b\u578b\u7684\u63d0\u793a\u6846</p> <p>\u6210\u529f\uff01</p> <p>\u8fd9\u662f failure \u7c7b\u578b\u7684\u63d0\u793a\u6846</p> <p>\u5931\u8d25\uff01</p> <p>\u8fd9\u662f bug \u7c7b\u578b\u7684\u63d0\u793a\u6846</p> <p>\u53d1\u73b0\u4e00\u4e2a bug\uff0c\u8bf7\u5c3d\u5feb\u4fee\u590d\uff01</p> \u8fd9\u662f note \u7c7b\u578b\u7684\u63d0\u793a\u6846 <p>\u63d0\u793a\uff1a\u66f4\u591a\u7cbe\u5f69\u5185\u5bb9\u8bb0\u5f97\u5173\u6ce8\u6211\u554a</p> <pre><code>\u7b2c\u4e8c\u884c\n\n\u7b2c\u4e09\u884c\n\n\u7b2c\u56db\u884c\n\n\u7b2c\u4e94\u884c\n...\n</code></pre>"}]}